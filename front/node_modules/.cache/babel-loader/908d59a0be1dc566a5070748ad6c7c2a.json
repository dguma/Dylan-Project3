{"ast":null,"code":"/*\n * file.js: Simple file storage engine for nconf files\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\nvar crypto = require('crypto'),\n    fs = require('fs'),\n    path = require('path'),\n    util = require('util'),\n    Secure = require('secure-keys'),\n    formats = require('../formats'),\n    Memory = require('./memory').Memory,\n    exists = fs.exists || path.exists,\n    existsSync = fs.existsSync || path.existsSync; //\n// ### function File (options)\n// #### @options {Object} Options for this instance\n// Constructor function for the File nconf store, a simple abstraction\n// around the Memory store that can persist configuration to disk.\n//\n\n\nvar File = exports.File = function (options) {\n  if (!options || !options.file) {\n    throw new Error('Missing required option `file`');\n  }\n\n  Memory.call(this, options);\n  this.type = 'file';\n  this.file = options.file;\n  this.dir = options.dir || process.cwd();\n  this.format = options.format || formats.json;\n  this.secure = options.secure;\n  this.spacing = options.json_spacing || options.spacing || 2;\n\n  if (this.secure) {\n    this.secure = Buffer.isBuffer(this.secure) || typeof this.secure === 'string' ? {\n      secret: this.secure.toString()\n    } : this.secure;\n    this.secure.alg = this.secure.alg || 'aes-256-ctr';\n\n    if (this.secure.secretPath) {\n      this.secure.secret = fs.readFileSync(this.secure.secretPath, 'utf8');\n    }\n\n    if (!this.secure.secret) {\n      throw new Error('secure.secret option is required');\n    }\n\n    this.keys = new Secure({\n      secret: this.secure.secret,\n      alg: this.secure.alg,\n      format: this.format\n    });\n  }\n\n  if (options.search) {\n    this.search(this.dir);\n  }\n}; // Inherit from the Memory store\n\n\nutil.inherits(File, Memory); //\n// ### function save (value, callback)\n// #### @value {Object} _Ignored_ Left here for consistency\n// #### @callback {function} Continuation to respond to when complete.\n// Saves the current configuration object to disk at `this.file`\n// using the format specified by `this.format`.\n//\n\nFile.prototype.save = function (value, callback) {\n  if (!callback) {\n    callback = value;\n    value = null;\n  }\n\n  fs.writeFile(this.file, this.stringify(), callback);\n}; //\n// ### function saveSync (value, callback)\n// #### @value {Object} _Ignored_ Left here for consistency\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Saves the current configuration object to disk at `this.file`\n// using the format specified by `this.format` synchronously.\n//\n\n\nFile.prototype.saveSync = function (value) {\n  fs.writeFileSync(this.file, this.stringify());\n  return this.store;\n}; //\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\n\n\nFile.prototype.load = function (callback) {\n  var self = this;\n  exists(self.file, function (exists) {\n    if (!exists) {\n      return callback(null, {});\n    } //\n    // Else, the path exists, read it from disk\n    //\n\n\n    fs.readFile(self.file, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      try {\n        // Deals with string that include BOM\n        var stringData = data.toString();\n\n        if (stringData.charAt(0) === '\\uFEFF') {\n          stringData = stringData.substr(1);\n        }\n\n        self.store = self.parse(stringData);\n      } catch (ex) {\n        return callback(new Error(\"Error parsing your configuration file: [\" + self.file + ']: ' + ex.message));\n      }\n\n      callback(null, self.store);\n    });\n  });\n}; //\n// ### function loadSync (callback)\n// Attempts to load the data stored in `this.file` synchronously\n// and responds appropriately.\n//\n\n\nFile.prototype.loadSync = function () {\n  if (!existsSync(this.file)) {\n    this.store = {};\n    return this.store;\n  } //\n  // Else, the path exists, read it from disk\n  //\n\n\n  try {\n    // Deals with file that include BOM\n    var fileData = fs.readFileSync(this.file, 'utf8');\n\n    if (fileData.charAt(0) === '\\uFEFF') {\n      fileData = fileData.substr(1);\n    }\n\n    this.store = this.parse(fileData);\n  } catch (ex) {\n    throw new Error(\"Error parsing your configuration file: [\" + this.file + ']: ' + ex.message);\n  }\n\n  return this.store;\n}; //\n// ### function stringify ()\n// Returns an encrypted version of the contents IIF\n// `this.secure` is enabled\n//\n\n\nFile.prototype.stringify = function () {\n  var data = this.store,\n      self = this;\n\n  if (this.secure) {\n    data = this.keys.encrypt(data);\n  }\n\n  return this.format.stringify(data, null, this.spacing);\n}; //\n// ### function parse (contents)\n// Returns a decrypted version of the contents IFF\n// `this.secure` is enabled.\n//\n\n\nFile.prototype.parse = function (contents) {\n  var parsed = this.format.parse(contents),\n      self = this;\n\n  if (!this.secure) {\n    return parsed;\n  }\n\n  return this.keys.decrypt(parsed);\n}; //\n// ### function search (base)\n// #### @base {string} Base directory (or file) to begin searching for the target file.\n// Attempts to find `this.file` by iteratively searching up the\n// directory structure\n//\n\n\nFile.prototype.search = function (base) {\n  var looking = true,\n      fullpath,\n      previous,\n      stats;\n  base = base || process.cwd();\n\n  if (this.file[0] === '/') {\n    //\n    // If filename for this instance is a fully qualified path\n    // (i.e. it starts with a `'/'`) then check if it exists\n    //\n    try {\n      stats = fs.statSync(fs.realpathSync(this.file));\n\n      if (stats.isFile()) {\n        fullpath = this.file;\n        looking = false;\n      }\n    } catch (ex) {//\n      // Ignore errors\n      //\n    }\n  }\n\n  if (looking && base) {\n    //\n    // Attempt to stat the realpath located at `base`\n    // if the directory does not exist then return false.\n    //\n    try {\n      var stat = fs.statSync(fs.realpathSync(base));\n      looking = stat.isDirectory();\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  while (looking) {\n    //\n    // Iteratively look up the directory structure from `base`\n    //\n    try {\n      stats = fs.statSync(fs.realpathSync(fullpath = path.join(base, this.file)));\n      looking = stats.isDirectory();\n    } catch (ex) {\n      previous = base;\n      base = path.dirname(base);\n\n      if (previous === base) {\n        //\n        // If we've reached the top of the directory structure then simply use\n        // the default file path.\n        //\n        try {\n          stats = fs.statSync(fs.realpathSync(fullpath = path.join(this.dir, this.file)));\n\n          if (stats.isDirectory()) {\n            fullpath = undefined;\n          }\n        } catch (ex) {//\n          // Ignore errors\n          //\n        }\n\n        looking = false;\n      }\n    }\n  } //\n  // Set the file for this instance to the fullpath\n  // that we have found during the search. In the event that\n  // the search was unsuccessful use the original value for `this.file`.\n  //\n\n\n  this.file = fullpath || this.file;\n  return fullpath;\n};","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/nconf/lib/nconf/stores/file.js"],"names":["crypto","require","fs","path","util","Secure","formats","Memory","exists","existsSync","File","exports","options","file","Error","call","type","dir","process","cwd","format","json","secure","spacing","json_spacing","Buffer","isBuffer","secret","toString","alg","secretPath","readFileSync","keys","search","inherits","prototype","save","value","callback","writeFile","stringify","saveSync","writeFileSync","store","load","self","readFile","err","data","stringData","charAt","substr","parse","ex","message","loadSync","fileData","encrypt","contents","parsed","decrypt","base","looking","fullpath","previous","stats","statSync","realpathSync","isFile","stat","isDirectory","join","dirname","undefined"],"mappings":"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","sourcesContent":["/*\n * file.js: Simple file storage engine for nconf files\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar crypto = require('crypto'),\n    fs = require('fs'),\n    path = require('path'),\n    util = require('util'),\n    Secure = require('secure-keys'),\n    formats = require('../formats'),\n    Memory = require('./memory').Memory,\n    exists = fs.exists || path.exists,\n    existsSync = fs.existsSync || path.existsSync;\n\n//\n// ### function File (options)\n// #### @options {Object} Options for this instance\n// Constructor function for the File nconf store, a simple abstraction\n// around the Memory store that can persist configuration to disk.\n//\nvar File = exports.File = function (options) {\n  if (!options || !options.file) {\n    throw new Error ('Missing required option `file`');\n  }\n\n  Memory.call(this, options);\n\n  this.type    = 'file';\n  this.file    = options.file;\n  this.dir     = options.dir    || process.cwd();\n  this.format  = options.format || formats.json;\n  this.secure  = options.secure;\n  this.spacing = options.json_spacing\n    || options.spacing\n    || 2;\n\n  if (this.secure) {\n    this.secure = Buffer.isBuffer(this.secure) || typeof this.secure === 'string'\n      ? { secret: this.secure.toString() }\n      : this.secure;\n\n    this.secure.alg = this.secure.alg || 'aes-256-ctr';\n    if (this.secure.secretPath) {\n      this.secure.secret = fs.readFileSync(this.secure.secretPath, 'utf8');\n    }\n\n    if (!this.secure.secret) {\n      throw new Error('secure.secret option is required');\n    }\n\n    this.keys = new Secure({\n      secret: this.secure.secret,\n      alg: this.secure.alg,\n      format: this.format\n    });\n  }\n\n  if (options.search) {\n    this.search(this.dir);\n  }\n};\n\n// Inherit from the Memory store\nutil.inherits(File, Memory);\n\n//\n// ### function save (value, callback)\n// #### @value {Object} _Ignored_ Left here for consistency\n// #### @callback {function} Continuation to respond to when complete.\n// Saves the current configuration object to disk at `this.file`\n// using the format specified by `this.format`.\n//\nFile.prototype.save = function (value, callback) {\n  if (!callback) {\n    callback = value;\n    value = null;\n  }\n\n  fs.writeFile(this.file, this.stringify(), callback);\n};\n\n//\n// ### function saveSync (value, callback)\n// #### @value {Object} _Ignored_ Left here for consistency\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Saves the current configuration object to disk at `this.file`\n// using the format specified by `this.format` synchronously.\n//\nFile.prototype.saveSync = function (value) {\n  fs.writeFileSync(this.file, this.stringify());\n  return this.store;\n};\n\n//\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\nFile.prototype.load = function (callback) {\n  var self = this;\n\n  exists(self.file, function (exists) {\n    if (!exists) {\n      return callback(null, {});\n    }\n\n    //\n    // Else, the path exists, read it from disk\n    //\n    fs.readFile(self.file, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      try {\n        // Deals with string that include BOM\n        var stringData = data.toString();\n        if (stringData.charAt(0) === '\\uFEFF') {\n          stringData = stringData.substr(1);\n        }\n\n        self.store = self.parse(stringData);\n      }\n      catch (ex) {\n        return callback(new Error(\"Error parsing your configuration file: [\" + self.file + ']: ' + ex.message));\n      }\n\n      callback(null, self.store);\n    });\n  });\n};\n\n//\n// ### function loadSync (callback)\n// Attempts to load the data stored in `this.file` synchronously\n// and responds appropriately.\n//\nFile.prototype.loadSync = function () {\n  if (!existsSync(this.file)) {\n    this.store = {};\n    return this.store;\n  }\n\n  //\n  // Else, the path exists, read it from disk\n  //\n  try {\n    // Deals with file that include BOM\n    var fileData = fs.readFileSync(this.file, 'utf8');\n    if (fileData.charAt(0) === '\\uFEFF') {\n      fileData = fileData.substr(1);\n    }\n\n    this.store = this.parse(fileData);\n  }\n  catch (ex) {\n    throw new Error(\"Error parsing your configuration file: [\" + this.file + ']: ' + ex.message);\n  }\n\n  return this.store;\n};\n\n//\n// ### function stringify ()\n// Returns an encrypted version of the contents IIF\n// `this.secure` is enabled\n//\nFile.prototype.stringify = function () {\n  var data = this.store,\n      self = this;\n\n  if (this.secure) {\n    data = this.keys.encrypt(data);\n  }\n\n  return this.format.stringify(data, null, this.spacing);\n};\n\n//\n// ### function parse (contents)\n// Returns a decrypted version of the contents IFF\n// `this.secure` is enabled.\n//\nFile.prototype.parse = function (contents) {\n  var parsed = this.format.parse(contents),\n      self = this;\n\n  if (!this.secure) {\n    return parsed;\n  }\n\n  return this.keys.decrypt(parsed);\n\n};\n\n\n//\n// ### function search (base)\n// #### @base {string} Base directory (or file) to begin searching for the target file.\n// Attempts to find `this.file` by iteratively searching up the\n// directory structure\n//\nFile.prototype.search = function (base) {\n  var looking = true,\n      fullpath,\n      previous,\n      stats;\n\n  base = base || process.cwd();\n\n  if (this.file[0] === '/') {\n    //\n    // If filename for this instance is a fully qualified path\n    // (i.e. it starts with a `'/'`) then check if it exists\n    //\n    try {\n      stats = fs.statSync(fs.realpathSync(this.file));\n      if (stats.isFile()) {\n        fullpath = this.file;\n        looking = false;\n      }\n    }\n    catch (ex) {\n      //\n      // Ignore errors\n      //\n    }\n  }\n\n  if (looking && base) {\n    //\n    // Attempt to stat the realpath located at `base`\n    // if the directory does not exist then return false.\n    //\n    try {\n      var stat = fs.statSync(fs.realpathSync(base));\n      looking = stat.isDirectory();\n    }\n    catch (ex) {\n      return false;\n    }\n  }\n\n  while (looking) {\n    //\n    // Iteratively look up the directory structure from `base`\n    //\n    try {\n      stats = fs.statSync(fs.realpathSync(fullpath = path.join(base, this.file)));\n      looking = stats.isDirectory();\n    }\n    catch (ex) {\n      previous = base;\n      base = path.dirname(base);\n\n      if (previous === base) {\n        //\n        // If we've reached the top of the directory structure then simply use\n        // the default file path.\n        //\n        try {\n          stats = fs.statSync(fs.realpathSync(fullpath = path.join(this.dir, this.file)));\n          if (stats.isDirectory()) {\n            fullpath = undefined;\n          }\n        }\n        catch (ex) {\n          //\n          // Ignore errors\n          //\n        }\n\n        looking = false;\n      }\n    }\n  }\n\n  //\n  // Set the file for this instance to the fullpath\n  // that we have found during the search. In the event that\n  // the search was unsuccessful use the original value for `this.file`.\n  //\n  this.file = fullpath || this.file;\n\n  return fullpath;\n};\n"]},"metadata":{},"sourceType":"script"}