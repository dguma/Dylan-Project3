{"ast":null,"code":"/*!\n * Module dependencies.\n */\nvar readPref = require('./drivers').ReadPreference;\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar VirtualType = require('./virtualtype');\n\nvar utils = require('./utils');\n\nvar MongooseTypes;\n\nvar Kareem = require('kareem');\n\nvar each = require('async/each');\n\nvar SchemaType = require('./schematype');\n\nvar mpath = require('mpath');\n\nvar IS_KAREEM_HOOK = {\n  aggregate: true,\n  count: true,\n  find: true,\n  findOne: true,\n  findOneAndUpdate: true,\n  findOneAndRemove: true,\n  insertMany: true,\n  replaceOne: true,\n  update: true,\n  updateMany: true,\n  updateOne: true\n};\n/**\n * Schema constructor.\n *\n * ####Example:\n *\n *     var child = new Schema({ name: String });\n *     var schema = new Schema({ name: String, age: Number, children: [child] });\n *     var Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * ####Options:\n *\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\n * - [capped](/docs/guide.html#capped): bool - defaults to false\n * - [collection](/docs/guide.html#collection): string - no default\n * - [emitIndexErrors](/docs/guide.html#emitIndexErrors): bool - defaults to false.\n * - [id](/docs/guide.html#id): bool - defaults to true\n * - [_id](/docs/guide.html#_id): bool - defaults to true\n * - `minimize`: bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\n * - [read](/docs/guide.html#read): string\n * - [safe](/docs/guide.html#safe): bool - defaults to true.\n * - [shardKey](/docs/guide.html#shardKey): bool - defaults to `null`\n * - [strict](/docs/guide.html#strict): bool - defaults to true\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\n * - [toObject](/docs/guide.html#toObject) - object - no default\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [useNestedStrict](/docs/guide.html#useNestedStrict) - boolean - defaults to false\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [versionKey](/docs/guide.html#versionKey): string - defaults to \"__v\"\n * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)\n *\n * ####Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object} definition\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = {};\n  this.statics = {};\n  this.tree = {};\n  this.query = {};\n  this.childSchemas = [];\n  this.plugins = [];\n  this.s = {\n    hooks: new Kareem(),\n    kareemHooks: IS_KAREEM_HOOK\n  };\n  this.options = this.defaultOptions(options); // build paths\n\n  if (obj) {\n    this.add(obj);\n  } // check if _id's value is a subdocument (gh-2276)\n\n\n  var _idSubDoc = obj && obj._id && utils.isObject(obj._id); // ensure the documents get an auto _id unless disabled\n\n\n  var auto_id = !this.paths['_id'] && !this.options.noId && this.options._id && !_idSubDoc;\n\n  if (auto_id) {\n    var _obj = {\n      _id: {\n        auto: true\n      }\n    };\n    _obj._id[this.options.typeKey] = Schema.ObjectId;\n    this.add(_obj);\n  }\n\n  for (var i = 0; i < this._defaultMiddleware.length; ++i) {\n    var m = this._defaultMiddleware[i];\n    this[m.kind](m.hook, !!m.isAsync, m.fn);\n  }\n\n  if (this.options.timestamps) {\n    this.setupTimestamp(this.options.timestamps);\n  } // Assign virtual properties based on alias option\n\n\n  aliasFields(this);\n}\n/*!\n * Create virtual properties with alias field\n */\n\n\nfunction aliasFields(schema) {\n  for (var path in schema.paths) {\n    if (!schema.paths[path].options) continue;\n    var prop = schema.paths[path].path;\n    var alias = schema.paths[path].options.alias;\n\n    if (alias) {\n      if ('string' === typeof alias && alias.length > 0) {\n        if (schema.aliases[alias]) {\n          throw new Error('Duplicate alias, alias ' + alias + ' is used more than once');\n        } else {\n          schema.aliases[alias] = prop;\n        }\n\n        schema.virtual(alias).get(function (p) {\n          return function () {\n            if (typeof this.get === 'function') {\n              return this.get(p);\n            }\n\n            return this[p];\n          };\n        }(prop)).set(function (p) {\n          return function (v) {\n            return this.set(p, v);\n          };\n        }(prop));\n      } else {\n        throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n      }\n    }\n  }\n}\n/*!\n * Inherit from EventEmitter.\n */\n\n\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n/**\n * Default middleware attached to a schema. Cannot be changed.\n *\n * This field is used to make sure discriminators don't get multiple copies of\n * built-in middleware. Declared as a constant because changing this at runtime\n * may lead to instability with Model.prototype.discriminator().\n *\n * @api private\n * @property _defaultMiddleware\n */\n\nObject.defineProperty(Schema.prototype, '_defaultMiddleware', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: [{\n    kind: 'pre',\n    hook: 'remove',\n    isAsync: true,\n    fn: function (next, done) {\n      if (this.ownerDocument) {\n        done();\n        next();\n        return;\n      }\n\n      var subdocs = this.$__getAllSubdocs();\n\n      if (!subdocs.length) {\n        done();\n        next();\n        return;\n      }\n\n      each(subdocs, function (subdoc, cb) {\n        subdoc.remove({\n          noop: true\n        }, function (err) {\n          cb(err);\n        });\n      }, function (error) {\n        if (error) {\n          done(error);\n          return;\n        }\n\n        next();\n        done();\n      });\n    }\n  }]\n});\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n/**\n * The original object passed to the schema constructor\n *\n * ####Example:\n *\n *     var schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n */\n\nSchema.prototype.obj;\n/**\n * Schema as flat paths\n *\n * ####Example:\n *     {\n *         '_id'        : SchemaType,\n *       , 'nested.key' : SchemaType,\n *     }\n *\n * @api private\n * @property paths\n */\n\nSchema.prototype.paths;\n/**\n * Schema as a tree\n *\n * ####Example:\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n */\n\nSchema.prototype.tree;\n/**\n * Returns a deep copy of the schema\n *\n * @return {Schema} the cloned schema\n * @api public\n */\n\nSchema.prototype.clone = function () {\n  var s = new Schema(this.paths, this.options); // Clone the call queue\n\n  var cloneOpts = {\n    retainKeyOrder: true\n  };\n  s.callQueue = this.callQueue.map(function (f) {\n    return f;\n  });\n  s.methods = utils.clone(this.methods, cloneOpts);\n  s.statics = utils.clone(this.statics, cloneOpts);\n  s.query = utils.clone(this.query, cloneOpts);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = utils.clone(this._indexes, cloneOpts);\n  s.s.hooks = this.s.hooks.clone();\n  return s;\n};\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\n\nSchema.prototype.defaultOptions = function (options) {\n  if (options && options.safe === false) {\n    options.safe = {\n      w: 0\n    };\n  }\n\n  if (options && options.safe && options.safe.w === 0) {\n    // if you turn off safe writes, then versioning goes off as well\n    options.versionKey = false;\n  }\n\n  this._userProvidedOptions = utils.clone(options, {\n    retainKeyOrder: true\n  });\n  options = utils.options({\n    strict: true,\n    bufferCommands: true,\n    capped: false,\n    // { size, max, autoIndexId }\n    versionKey: '__v',\n    discriminatorKey: '__t',\n    minimize: true,\n    autoIndex: null,\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    // the following are only applied at construction time\n    noId: false,\n    // deprecated, use { _id: false }\n    _id: true,\n    noVirtualId: false,\n    // deprecated, use { id: false }\n    id: true,\n    typeKey: 'type',\n    retainKeyOrder: false\n  }, options);\n\n  if (options.read) {\n    options.read = readPref(options.read);\n  }\n\n  return options;\n};\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * ####Example:\n *\n *     var ToySchema = new Schema;\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n * @param {Object} obj\n * @param {String} prefix\n * @api public\n */\n\n\nSchema.prototype.add = function add(obj, prefix) {\n  prefix = prefix || '';\n  var keys = Object.keys(obj);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n\n    if (obj[key] == null) {\n      throw new TypeError('Invalid value for schema path `' + prefix + key + '`');\n    }\n\n    if (Array.isArray(obj[key]) && obj[key].length === 1 && obj[key][0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + prefix + key + '`');\n    }\n\n    if (utils.isObject(obj[key]) && (!obj[key].constructor || utils.getFunctionName(obj[key].constructor) === 'Object') && (!obj[key][this.options.typeKey] || this.options.typeKey === 'type' && obj[key].type.type)) {\n      if (Object.keys(obj[key]).length) {\n        // nested object { last: { name: String }}\n        this.nested[prefix + key] = true;\n        this.add(obj[key], prefix + key + '.');\n      } else {\n        if (prefix) {\n          this.nested[prefix.substr(0, prefix.length - 1)] = true;\n        }\n\n        this.path(prefix + key, obj[key]); // mixed type\n      }\n    } else {\n      if (prefix) {\n        this.nested[prefix.substr(0, prefix.length - 1)] = true;\n      }\n\n      this.path(prefix + key, obj[key]);\n    }\n  }\n};\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.\n *\n *      on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      var schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n */\n\n\nSchema.reserved = Object.create(null);\nvar reserved = Schema.reserved; // Core object\n\nreserved['prototype'] = // EventEmitter\nreserved.emit = reserved.on = reserved.once = reserved.listeners = reserved.removeListener = // document properties and functions\nreserved.collection = reserved.db = reserved.errors = reserved.init = reserved.isModified = reserved.isNew = reserved.get = reserved.modelName = reserved.save = reserved.schema = reserved.toObject = reserved.validate = reserved.remove = // hooks.js\nreserved._pres = reserved._posts = 1;\n/*!\n * Document keys to print warnings for\n */\n\nvar warnings = {};\nwarnings.increment = '`increment` should not be used as a schema path name ' + 'unless you have disabled versioning.';\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * ####Example\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path\n * @param {Object} constructor\n * @api public\n */\n\nSchema.prototype.path = function (path, obj) {\n  if (obj === undefined) {\n    if (this.paths[path]) {\n      return this.paths[path];\n    }\n\n    if (this.subpaths[path]) {\n      return this.subpaths[path];\n    }\n\n    if (this.singleNestedPaths[path]) {\n      return this.singleNestedPaths[path];\n    } // subpaths?\n\n\n    return /\\.\\d+\\.?.*$/.test(path) ? getPositionalPath(this, path) : undefined;\n  } // some path names conflict with document methods\n\n\n  if (reserved[path]) {\n    throw new Error('`' + path + '` may not be used as a schema pathname');\n  }\n\n  if (warnings[path]) {\n    console.log('WARN: ' + warnings[path]);\n  } // update the tree\n\n\n  var subpaths = path.split(/\\./),\n      last = subpaths.pop(),\n      branch = this.tree;\n  subpaths.forEach(function (sub, i) {\n    if (!branch[sub]) {\n      branch[sub] = {};\n    }\n\n    if (typeof branch[sub] !== 'object') {\n      var msg = 'Cannot set nested path `' + path + '`. ' + 'Parent path `' + subpaths.slice(0, i).concat([sub]).join('.') + '` already set to type ' + branch[sub].name + '.';\n      throw new Error(msg);\n    }\n\n    branch = branch[sub];\n  });\n  branch[last] = utils.clone(obj);\n  this.paths[path] = Schema.interpretAsType(path, obj, this.options);\n\n  if (this.paths[path].$isSingleNested) {\n    for (var key in this.paths[path].schema.paths) {\n      this.singleNestedPaths[path + '.' + key] = this.paths[path].schema.paths[key];\n    }\n\n    for (key in this.paths[path].schema.singleNestedPaths) {\n      this.singleNestedPaths[path + '.' + key] = this.paths[path].schema.singleNestedPaths[key];\n    }\n\n    this.childSchemas.push({\n      schema: this.paths[path].schema,\n      model: this.paths[path].caster\n    });\n  } else if (this.paths[path].$isMongooseDocumentArray) {\n    this.childSchemas.push({\n      schema: this.paths[path].schema,\n      model: this.paths[path].casterConstructor\n    });\n  }\n\n  return this;\n};\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @api private\n */\n\n\nSchema.interpretAsType = function (path, obj, options) {\n  if (obj instanceof SchemaType) {\n    return obj;\n  }\n\n  if (obj.constructor) {\n    var constructorName = utils.getFunctionName(obj.constructor);\n\n    if (constructorName !== 'Object') {\n      var oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  } // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n\n\n  var type = obj[options.typeKey] && (options.typeKey !== 'type' || !obj.type.type) ? obj[options.typeKey] : {};\n\n  if (utils.getFunctionName(type.constructor) === 'Object' || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || Array === type || type === 'array') {\n    // if it was specified through { type } look for `cast`\n    var cast = Array === type || type === 'array' ? obj.cast : type[0];\n\n    if (cast && cast.instanceOfSchema) {\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n\n    if (cast && cast[options.typeKey] && cast[options.typeKey].instanceOfSchema) {\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, Schema.interpretAsType(path, cast, options), obj);\n    }\n\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (cast && (!cast[options.typeKey] || options.typeKey === 'type' && cast.type.type) && utils.getFunctionName(cast.constructor) === 'Object') {\n      if (Object.keys(cast).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        var childSchemaOptions = {\n          minimize: options.minimize\n        };\n\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        } //propagate 'strict' option to child schema\n\n\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        } //propagate 'runSettersOnQuery' option to child schema\n\n\n        if (options.hasOwnProperty('runSettersOnQuery')) {\n          childSchemaOptions.runSettersOnQuery = options.runSettersOnQuery;\n        }\n\n        var childSchema = new Schema(cast, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type) ? cast[options.typeKey] : cast;\n      name = typeof type === 'string' ? type : type.schemaName || utils.getFunctionName(type);\n\n      if (!(name in MongooseTypes)) {\n        throw new TypeError('Undefined type `' + name + '` at array `' + path + '`');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Embedded(type, path, obj);\n  }\n\n  var name;\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else {\n    name = typeof type === 'string' ? type // If not string, `type` is a function. Outside of IE, function.name\n    // gives you the function name. In IE, you need to compute it\n    : type.schemaName || utils.getFunctionName(type);\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n\n  if (undefined == MongooseTypes[name]) {\n    throw new TypeError('Undefined type `' + name + '` at `' + path + '`\\n  Did you try nesting Schemas? ' + 'You can only nest using refs or arrays.');\n  }\n\n  obj = utils.clone(obj, {\n    retainKeyOrder: true\n  });\n\n  if (!('runSettersOnQuery' in obj)) {\n    obj.runSettersOnQuery = options.runSettersOnQuery;\n  }\n\n  return new MongooseTypes[name](path, obj);\n};\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and schemaType as arguments on each iteration.\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\n\nSchema.prototype.eachPath = function (fn) {\n  var keys = Object.keys(this.paths),\n      len = keys.length;\n\n  for (var i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * @api public\n * @param {Boolean} invalidate refresh the cache\n * @return {Array}\n */\n\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  var paths = Object.keys(this.paths),\n      i = paths.length,\n      ret = [];\n\n  while (i--) {\n    var path = paths[i];\n\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\n\nSchema.prototype.pathType = function (path) {\n  if (path in this.paths) {\n    return 'real';\n  }\n\n  if (path in this.virtuals) {\n    return 'virtual';\n  }\n\n  if (path in this.nested) {\n    return 'nested';\n  }\n\n  if (path in this.subpaths) {\n    return 'real';\n  }\n\n  if (path in this.singleNestedPaths) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path);\n  }\n\n  return 'adhocOrUndefined';\n};\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\n\nSchema.prototype.hasMixedParent = function (path) {\n  var subpaths = path.split(/\\./g);\n  path = '';\n\n  for (var i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n\n    if (path in this.paths && this.paths[path] instanceof MongooseTypes.Mixed) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\n\n\nSchema.prototype.setupTimestamp = function (timestamps) {\n  if (timestamps) {\n    var createdAt = handleTimestampOption(timestamps, 'createdAt');\n    var updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n    var schemaAdditions = {};\n\n    if (updatedAt && !this.paths[updatedAt]) {\n      schemaAdditions[updatedAt] = Date;\n    }\n\n    if (createdAt && !this.paths[createdAt]) {\n      schemaAdditions[createdAt] = Date;\n    }\n\n    this.add(schemaAdditions);\n    this.pre('save', function (next) {\n      var defaultTimestamp = new Date();\n      var auto_id = this._id && this._id.auto;\n\n      if (createdAt != null && !this.get(createdAt) && this.isSelected(createdAt)) {\n        this.set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);\n      }\n\n      if (updatedAt != null && (this.isNew || this.isModified())) {\n        var ts = defaultTimestamp;\n\n        if (this.isNew) {\n          if (createdAt != null) {\n            ts = this.get(createdAt);\n          } else if (auto_id) {\n            ts = this._id.getTimestamp();\n          }\n        }\n\n        this.set(updatedAt, ts);\n      }\n\n      next();\n    });\n\n    var genUpdates = function (currentUpdate, overwrite) {\n      var now = new Date();\n      var updates = {};\n      var _updates = updates;\n\n      if (overwrite) {\n        if (currentUpdate && currentUpdate.$set) {\n          currentUpdate = currentUpdate.$set;\n          updates.$set = {};\n          _updates = updates.$set;\n        }\n\n        if (updatedAt != null && !currentUpdate[updatedAt]) {\n          _updates[updatedAt] = now;\n        }\n\n        if (createdAt != null && !currentUpdate[createdAt]) {\n          _updates[createdAt] = now;\n        }\n\n        return updates;\n      }\n\n      updates = {\n        $set: {}\n      };\n      currentUpdate = currentUpdate || {};\n\n      if (updatedAt != null && (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {\n        updates.$set[updatedAt] = now;\n      }\n\n      if (createdAt != null) {\n        if (currentUpdate[createdAt]) {\n          delete currentUpdate[createdAt];\n        }\n\n        if (currentUpdate.$set && currentUpdate.$set[createdAt]) {\n          delete currentUpdate.$set[createdAt];\n        }\n\n        updates.$setOnInsert = {};\n        updates.$setOnInsert[createdAt] = now;\n      }\n\n      return updates;\n    };\n\n    this.methods.initializeTimestamps = function () {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n\n      return this;\n    };\n\n    this.pre('findOneAndUpdate', function (next) {\n      var overwrite = this.options.overwrite;\n      this.findOneAndUpdate({}, genUpdates(this.getUpdate(), overwrite), {\n        overwrite: overwrite\n      });\n      applyTimestampsToChildren(this);\n      next();\n    });\n    this.pre('update', function (next) {\n      var overwrite = this.options.overwrite;\n      this.update({}, genUpdates(this.getUpdate(), overwrite), {\n        overwrite: overwrite\n      });\n      applyTimestampsToChildren(this);\n      next();\n    });\n  }\n};\n/*!\n * ignore\n */\n\n\nfunction handleTimestampOption(arg, prop) {\n  if (typeof arg === 'boolean') {\n    return prop;\n  }\n\n  if (typeof arg[prop] === 'boolean') {\n    return arg[prop] ? prop : null;\n  }\n\n  if (!(prop in arg)) {\n    return prop;\n  }\n\n  return arg[prop];\n}\n/*!\n * ignore\n */\n\n\nfunction applyTimestampsToChildren(query) {\n  var now = new Date();\n  var update = query.getUpdate();\n  var keys = Object.keys(update);\n  var key;\n  var schema = query.model.schema;\n  var len;\n  var createdAt;\n  var updatedAt;\n  var timestamps;\n  var path;\n  var hasDollarKey = keys.length && keys[0].charAt(0) === '$';\n\n  if (hasDollarKey) {\n    if (update.$push) {\n      for (key in update.$push) {\n        var $path = schema.path(key);\n\n        if (update.$push[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {\n          timestamps = $path.schema.options.timestamps;\n          createdAt = handleTimestampOption(timestamps, 'createdAt');\n          updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n          if (update.$push[key].$each) {\n            update.$push[key].$each.forEach(function (subdoc) {\n              if (updatedAt != null) {\n                subdoc[updatedAt] = now;\n              }\n\n              if (createdAt != null) {\n                subdoc[createdAt] = now;\n              }\n            });\n          } else {\n            if (updatedAt != null) {\n              update.$push[key][updatedAt] = now;\n            }\n\n            if (createdAt != null) {\n              update.$push[key][createdAt] = now;\n            }\n          }\n        }\n      }\n    }\n\n    if (update.$set) {\n      for (key in update.$set) {\n        path = schema.path(key);\n\n        if (!path) {\n          continue;\n        }\n\n        if (Array.isArray(update.$set[key]) && path.$isMongooseDocumentArray) {\n          len = update.$set[key].length;\n          timestamps = schema.path(key).schema.options.timestamps;\n\n          if (timestamps) {\n            createdAt = handleTimestampOption(timestamps, 'createdAt');\n            updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n            for (var i = 0; i < len; ++i) {\n              if (updatedAt != null) {\n                update.$set[key][i][updatedAt] = now;\n              }\n\n              if (createdAt != null) {\n                update.$set[key][i][createdAt] = now;\n              }\n            }\n          }\n        } else if (update.$set[key] && path.$isSingleNested) {\n          timestamps = schema.path(key).schema.options.timestamps;\n\n          if (timestamps) {\n            createdAt = handleTimestampOption(timestamps, 'createdAt');\n            updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n            if (updatedAt != null) {\n              update.$set[key][updatedAt] = now;\n            }\n\n            if (createdAt != null) {\n              update.$set[key][createdAt] = now;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction getPositionalPathType(self, path) {\n  var subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n\n  if (subpaths.length < 2) {\n    return self.paths[subpaths[0]];\n  }\n\n  var val = self.path(subpaths[0]);\n  var isNested = false;\n\n  if (!val) {\n    return val;\n  }\n\n  var last = subpaths.length - 1,\n      subpath,\n      i = 1;\n\n  for (; i < subpaths.length; ++i) {\n    isNested = false;\n    subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        var oldVal = val;\n        val = new SchemaType(subpath);\n\n        val.cast = function (value, doc, init) {\n          return oldVal.cast(value, doc, init)[0];\n        };\n\n        val.caster = oldVal.caster;\n        val.schema = oldVal.schema;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n\n      break;\n    } // ignore if its just a position segment: path.0.subpath\n\n\n    if (!/\\D/.test(subpath)) {\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    var type = val.schema.pathType(subpath);\n    isNested = type === 'nested';\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[path] = val;\n\n  if (val) {\n    return 'real';\n  }\n\n  if (isNested) {\n    return 'nested';\n  }\n\n  return 'adhocOrUndefined';\n}\n/*!\n * ignore\n */\n\n\nfunction getPositionalPath(self, path) {\n  getPositionalPathType(self, path);\n  return self.subpaths[path];\n}\n/**\n * Adds a method call to the queue.\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\n\nSchema.prototype.queue = function (name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n/**\n * Defines a pre hook for the document.\n *\n * ####Example\n *\n *     var toySchema = new Schema(..);\n *\n *     toySchema.pre('save', function (next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     })\n *\n *     toySchema.pre('validate', function (next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     })\n *\n * @param {String} method\n * @param {Function} callback\n * @see hooks.js https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3\n * @api public\n */\n\n\nSchema.prototype.pre = function () {\n  var name = arguments[0];\n\n  if (IS_KAREEM_HOOK[name]) {\n    this.s.hooks.pre.apply(this.s.hooks, arguments);\n    return this;\n  }\n\n  return this.queue('pre', arguments);\n};\n/**\n * Defines a post hook for the document\n *\n *     var schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you run a find query');\n *     });\n *\n *     var Model = mongoose.model('Model', schema);\n *\n *     var m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String} method name of the method to hook\n * @param {Function} fn callback\n * @see middleware http://mongoosejs.com/docs/middleware.html\n * @see hooks.js https://www.npmjs.com/package/hooks-fixed\n * @see kareem http://npmjs.org/package/kareem\n * @api public\n */\n\n\nSchema.prototype.post = function (method, fn) {\n  if (IS_KAREEM_HOOK[method]) {\n    this.s.hooks.post.apply(this.s.hooks, arguments);\n    return this;\n  } // assuming that all callbacks with arity < 2 are synchronous post hooks\n\n\n  if (fn.length < 2) {\n    return this.queue('on', [arguments[0], function (doc) {\n      return fn.call(doc, doc);\n    }]);\n  }\n\n  if (fn.length === 3) {\n    this.s.hooks.post(method + ':error', fn);\n    return this;\n  }\n\n  return this.queue('post', [arguments[0], function (next) {\n    // wrap original function so that the callback goes last,\n    // for compatibility with old code that is using synchronous post hooks\n    var _this = this;\n\n    var args = Array.prototype.slice.call(arguments, 1);\n    fn.call(this, this, function (err) {\n      return next.apply(_this, [err].concat(args));\n    });\n  }]);\n};\n/**\n * Registers a plugin for this schema.\n *\n * @param {Function} plugin callback\n * @param {Object} [opts]\n * @see plugins\n * @api public\n */\n\n\nSchema.prototype.plugin = function (fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' + 'got \"' + typeof fn + '\"');\n  }\n\n  if (opts && opts.deduplicate) {\n    for (var i = 0; i < this.plugins.length; ++i) {\n      if (this.plugins[i].fn === fn) {\n        return this;\n      }\n    }\n  }\n\n  this.plugins.push({\n    fn: fn,\n    opts: opts\n  });\n  fn(this, opts);\n  return this;\n};\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     var Kitty = mongoose.model('Kitty', schema);\n *\n *     var fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     fizz.purr();\n *     fizz.scratch();\n *\n * @param {String|Object} method name\n * @param {Function} [fn]\n * @api public\n */\n\n\nSchema.prototype.method = function (name, fn) {\n  if (typeof name !== 'string') {\n    for (var i in name) {\n      this.methods[i] = name[i];\n    }\n  } else {\n    this.methods[name] = fn;\n  }\n\n  return this;\n};\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = new Schema(..);\n *     schema.static('findByName', function (name, callback) {\n *       return this.find({ name: name }, callback);\n *     });\n *\n *     var Drink = mongoose.model('Drink', schema);\n *     Drink.findByName('sanpellegrino', function (err, drinks) {\n *       //\n *     });\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name\n * @param {Function} [fn]\n * @api public\n */\n\n\nSchema.prototype.static = function (name, fn) {\n  if (typeof name !== 'string') {\n    for (var i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n\n  return this;\n};\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * ####Example\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)\n * @param {String} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @api public\n */\n\n\nSchema.prototype.index = function (fields, options) {\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n\n  this._indexes.push([fields, options]);\n\n  return this;\n};\n/**\n * Sets/gets a schema option.\n *\n * ####Example\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key option name\n * @param {Object} [value] if not passed, the current option value is returned\n * @see Schema ./\n * @api public\n */\n\n\nSchema.prototype.set = function (key, value, _tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      this.options[key] = readPref(value, _tags);\n      break;\n\n    case 'safe':\n      this.options[key] = value === false ? {\n        w: 0\n      } : value;\n      break;\n\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      break;\n\n    default:\n      this.options[key] = value;\n  }\n\n  return this;\n};\n/**\n * Gets a schema option.\n *\n * @param {String} key option name\n * @api public\n */\n\n\nSchema.prototype.get = function (key) {\n  return this.options[key];\n};\n/**\n * The allowed index types\n *\n * @static indexTypes\n * @receiver Schema\n * @api public\n */\n\n\nvar indexTypes = '2d 2dsphere hashed text'.split(' ');\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function () {\n    return indexTypes;\n  },\n  set: function () {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()`\n * or by `index: true` in a path's options.\n *\n * @api public\n */\n\nSchema.prototype.indexes = function () {\n  'use strict';\n\n  var indexes = [];\n  var schemaStack = [];\n\n  var collectIndexes = function (schema, prefix) {\n    // Ignore infinitely nested schemas, if we've already seen this schema\n    // along this path there must be a cycle\n    if (schemaStack.indexOf(schema) !== -1) {\n      return;\n    }\n\n    schemaStack.push(schema);\n    prefix = prefix || '';\n    var key, path, index, field, isObject, options, type;\n    var keys = Object.keys(schema.paths);\n\n    for (var i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      path = schema.paths[key];\n\n      if (path instanceof MongooseTypes.DocumentArray || path.$isSingleNested) {\n        if (path.options.excludeIndexes !== true) {\n          collectIndexes(path.schema, prefix + key + '.');\n        }\n      } else {\n        index = path._index || path.caster && path.caster._index;\n\n        if (index !== false && index !== null && index !== undefined) {\n          field = {};\n          isObject = utils.isObject(index);\n          options = isObject ? index : {};\n          type = typeof index === 'string' ? index : isObject ? index.type : false;\n\n          if (type && ~Schema.indexTypes.indexOf(type)) {\n            field[prefix + key] = type;\n          } else if (options.text) {\n            field[prefix + key] = 'text';\n            delete options.text;\n          } else {\n            field[prefix + key] = 1;\n          }\n\n          delete options.type;\n\n          if (!('background' in options)) {\n            options.background = true;\n          }\n\n          indexes.push([field, options]);\n        }\n      }\n    }\n\n    schemaStack.pop();\n\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function (index) {\n        if (!('background' in index[1])) {\n          index[1].background = true;\n        }\n      });\n\n      indexes = indexes.concat(schema._indexes);\n    }\n  };\n\n  collectIndexes(this);\n  return indexes;\n  /*!\n   * Checks for indexes added to subdocs using Schema.index().\n   * These indexes need their paths prefixed properly.\n   *\n   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]\n   */\n\n  function fixSubIndexPaths(schema, prefix) {\n    var subindexes = schema._indexes,\n        len = subindexes.length,\n        indexObj,\n        newindex,\n        klen,\n        keys,\n        key,\n        i = 0,\n        j;\n\n    for (i = 0; i < len; ++i) {\n      indexObj = subindexes[i][0];\n      keys = Object.keys(indexObj);\n      klen = keys.length;\n      newindex = {}; // use forward iteration, order matters\n\n      for (j = 0; j < klen; ++j) {\n        key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n\n      indexes.push([newindex, subindexes[i][1]]);\n    }\n  }\n};\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name\n * @param {Object} [options]\n * @return {VirtualType}\n */\n\n\nSchema.prototype.virtual = function (name, options) {\n  if (options && options.ref) {\n    if (!options.localField) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (!options.foreignField) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function (next, obj) {\n      if (mpath.has(name, obj)) {\n        var _v = mpath.get(name, obj);\n\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n\n      if (this.ownerDocument) {\n        next();\n        return this;\n      } else {\n        next();\n      }\n    });\n    var virtual = this.virtual(name);\n    virtual.options = options;\n    return virtual.get(function () {\n      if (!this.$$populatedVirtuals) {\n        this.$$populatedVirtuals = {};\n      }\n\n      if (name in this.$$populatedVirtuals) {\n        return this.$$populatedVirtuals[name];\n      }\n\n      return null;\n    }).set(function (_v) {\n      if (!this.$$populatedVirtuals) {\n        this.$$populatedVirtuals = {};\n      }\n\n      if (options.justOne) {\n        this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;\n\n        if (typeof this.$$populatedVirtuals[name] !== 'object') {\n          this.$$populatedVirtuals[name] = null;\n        }\n      } else {\n        this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];\n        this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function (doc) {\n          return doc && typeof doc === 'object';\n        });\n      }\n    });\n  }\n\n  var virtuals = this.virtuals;\n  var parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' + ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function (mem, part, i) {\n    mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});\n    return mem[part];\n  }, this.tree);\n  return virtuals[name];\n};\n/*!\n * ignore\n */\n\n\nSchema.prototype._getVirtual = function (name) {\n  return _getVirtual(this, name);\n};\n/*!\n * ignore\n */\n\n\nfunction _getVirtual(schema, name) {\n  if (schema.virtuals[name]) {\n    return schema.virtuals[name];\n  }\n\n  var parts = name.split('.');\n  var cur = '';\n  var nestedSchemaPath = '';\n\n  for (var i = 0; i < parts.length; ++i) {\n    cur += (cur.length > 0 ? '.' : '') + parts[i];\n\n    if (schema.virtuals[cur]) {\n      if (i === parts.length - 1) {\n        schema.virtuals[cur].$nestedSchemaPath = nestedSchemaPath;\n        return schema.virtuals[cur];\n      }\n\n      continue;\n    } else if (schema.paths[cur] && schema.paths[cur].schema) {\n      schema = schema.paths[cur].schema;\n      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + cur;\n      cur = '';\n    } else {\n      return null;\n    }\n  }\n}\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name\n * @return {VirtualType}\n */\n\n\nSchema.prototype.virtualpath = function (name) {\n  return this.virtuals[name];\n};\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * @param {String|Array} path\n *\n * @api public\n */\n\n\nSchema.prototype.remove = function (path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n\n  if (Array.isArray(path)) {\n    path.forEach(function (name) {\n      if (this.path(name)) {\n        delete this.paths[name];\n        var pieces = name.split('.');\n        var last = pieces.pop();\n        var branch = this.tree;\n\n        for (var i = 0; i < pieces.length; ++i) {\n          branch = branch[pieces[i]];\n        }\n\n        delete branch[last];\n      }\n    }, this);\n  }\n};\n/**\n * Loads an ES6 class into a schema. Maps setters + getters, static methods, and instance methods to schema virtuals, statics, and methods.\n *\n * @param {Function} model\n */\n\n\nSchema.prototype.loadClass = function (model, virtualsOnly) {\n  if (model === Object.prototype || model === Function.prototype || model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model)); // Add static methods\n\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function (name) {\n      if (name.match(/^(length|name|prototype)$/)) {\n        return;\n      }\n\n      var method = Object.getOwnPropertyDescriptor(model, name);\n\n      if (typeof method.value === 'function') {\n        this.static(name, method.value);\n      }\n    }, this);\n  } // Add methods and virtuals\n\n\n  Object.getOwnPropertyNames(model.prototype).forEach(function (name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n\n    var method = Object.getOwnPropertyDescriptor(model.prototype, name);\n\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n\n    if (typeof method.get === 'function') {\n      this.virtual(name).get(method.get);\n    }\n\n    if (typeof method.set === 'function') {\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n  return this;\n};\n/*!\n * ignore\n */\n\n\nSchema.prototype._getSchema = function (path) {\n  var _this = this;\n\n  var pathschema = _this.path(path);\n\n  var resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    var p = parts.length + 1;\n    var foundschema;\n    var trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          } // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n\n\n          if (p !== parts.length && foundschema.schema) {\n            var ret;\n\n            if (parts[p] === '$') {\n              if (p + 1 === parts.length) {\n                // comments.$\n                return foundschema;\n              } // comments.$.comments.$.title\n\n\n              ret = search(parts.slice(p + 1), foundschema.schema);\n\n              if (ret) {\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n              }\n\n              return ret;\n            } // this is the last path of the selector\n\n\n            ret = search(parts.slice(p), foundschema.schema);\n\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n            }\n\n            return ret;\n          }\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n        return foundschema;\n      }\n    }\n  } // look for arrays\n\n\n  var parts = path.split('.');\n\n  for (var i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n\n  return search(parts, _this);\n};\n/*!\n * ignore\n */\n\n\nSchema.prototype._getPathType = function (path) {\n  var _this = this;\n\n  var pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    var p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return {\n              schema: foundschema,\n              pathType: 'mixed'\n            };\n          } // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n\n\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$') {\n              if (p === parts.length - 1) {\n                return {\n                  schema: foundschema,\n                  pathType: 'nested'\n                };\n              } // comments.$.comments.$.title\n\n\n              return search(parts.slice(p + 1), foundschema.schema);\n            } // this is the last path of the selector\n\n\n            return search(parts.slice(p), foundschema.schema);\n          }\n\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n\n        return {\n          schema: foundschema,\n          pathType: 'real'\n        };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return {\n          schema: schema,\n          pathType: 'nested'\n        };\n      }\n    }\n\n    return {\n      schema: foundschema || schema,\n      pathType: 'undefined'\n    };\n  } // look for arrays\n\n\n  return search(path.split('.'), _this);\n};\n/*!\n * Module exports.\n */\n\n\nmodule.exports = exports = Schema; // require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     var ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * ####Types:\n *\n * - [String](#schema-string-js)\n * - [Number](#schema-number-js)\n * - [Boolean](#schema-boolean-js) | Bool\n * - [Array](#schema-array-js)\n * - [Buffer](#schema-buffer-js)\n * - [Date](#schema-date-js)\n * - [ObjectId](#schema-objectid-js) | Oid\n * - [Mixed](#schema-mixed-js)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     var Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/mongoose/lib/schema.js"],"names":["readPref","require","ReadPreference","EventEmitter","VirtualType","utils","MongooseTypes","Kareem","each","SchemaType","mpath","IS_KAREEM_HOOK","aggregate","count","find","findOne","findOneAndUpdate","findOneAndRemove","insertMany","replaceOne","update","updateMany","updateOne","Schema","obj","options","paths","aliases","subpaths","virtuals","singleNestedPaths","nested","inherits","callQueue","_indexes","methods","statics","tree","query","childSchemas","plugins","s","hooks","kareemHooks","defaultOptions","add","_idSubDoc","_id","isObject","auto_id","noId","_obj","auto","typeKey","ObjectId","i","_defaultMiddleware","length","m","kind","hook","isAsync","fn","timestamps","setupTimestamp","aliasFields","schema","path","prop","alias","Error","virtual","get","p","set","v","prototype","Object","create","constructor","instanceOfSchema","defineProperty","configurable","enumerable","writable","value","next","done","ownerDocument","subdocs","$__getAllSubdocs","subdoc","cb","remove","noop","err","error","clone","cloneOpts","retainKeyOrder","map","f","Array","slice","call","safe","w","versionKey","_userProvidedOptions","strict","bufferCommands","capped","discriminatorKey","minimize","autoIndex","shardKey","read","validateBeforeSave","noVirtualId","id","prefix","keys","key","TypeError","isArray","getFunctionName","type","substr","reserved","emit","on","once","listeners","removeListener","collection","db","errors","init","isModified","isNew","modelName","save","toObject","validate","_pres","_posts","warnings","increment","undefined","test","getPositionalPath","console","log","split","last","pop","branch","forEach","sub","msg","concat","join","name","interpretAsType","$isSingleNested","push","model","caster","$isMongooseDocumentArray","casterConstructor","constructorName","oldObj","Mixed","cast","DocumentArray","charAt","toUpperCase","substring","childSchemaOptions","hasOwnProperty","runSettersOnQuery","childSchema","$implicitlyCreated","schemaName","Embedded","Buffer","isBuffer","eachPath","len","requiredPaths","invalidate","_requiredpaths","ret","isRequired","indexedPaths","_indexedpaths","indexes","pathType","getPositionalPathType","hasMixedParent","createdAt","handleTimestampOption","updatedAt","schemaAdditions","Date","pre","defaultTimestamp","isSelected","getTimestamp","ts","genUpdates","currentUpdate","overwrite","now","updates","_updates","$set","$currentDate","$setOnInsert","initializeTimestamps","getUpdate","applyTimestampsToChildren","arg","hasDollarKey","$push","$path","$each","self","filter","Boolean","val","isNested","subpath","oldVal","doc","queue","args","arguments","apply","post","method","_this","plugin","opts","deduplicate","static","index","fields","expires","_tags","indexTypes","schemaStack","collectIndexes","indexOf","field","excludeIndexes","_index","text","background","fixSubIndexPaths","subindexes","indexObj","newindex","klen","j","ref","localField","foreignField","has","_v","$$populatedVirtuals","justOne","unset","parts","reduce","mem","part","_getVirtual","cur","nestedSchemaPath","$nestedSchemaPath","virtualpath","pieces","loadClass","virtualsOnly","Function","getPrototypeOf","getOwnPropertyNames","match","getOwnPropertyDescriptor","_getSchema","pathschema","resultPath","$fullPath","search","foundschema","trypath","$isUnderneathDocArray","_getPathType","module","exports","Types"],"mappings":"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","sourcesContent":["/*!\n * Module dependencies.\n */\n\nvar readPref = require('./drivers').ReadPreference;\nvar EventEmitter = require('events').EventEmitter;\nvar VirtualType = require('./virtualtype');\nvar utils = require('./utils');\nvar MongooseTypes;\nvar Kareem = require('kareem');\nvar each = require('async/each');\nvar SchemaType = require('./schematype');\nvar mpath = require('mpath');\n\nvar IS_KAREEM_HOOK = {\n  aggregate: true,\n  count: true,\n  find: true,\n  findOne: true,\n  findOneAndUpdate: true,\n  findOneAndRemove: true,\n  insertMany: true,\n  replaceOne: true,\n  update: true,\n  updateMany: true,\n  updateOne: true\n};\n\n/**\n * Schema constructor.\n *\n * ####Example:\n *\n *     var child = new Schema({ name: String });\n *     var schema = new Schema({ name: String, age: Number, children: [child] });\n *     var Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * ####Options:\n *\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\n * - [capped](/docs/guide.html#capped): bool - defaults to false\n * - [collection](/docs/guide.html#collection): string - no default\n * - [emitIndexErrors](/docs/guide.html#emitIndexErrors): bool - defaults to false.\n * - [id](/docs/guide.html#id): bool - defaults to true\n * - [_id](/docs/guide.html#_id): bool - defaults to true\n * - `minimize`: bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\n * - [read](/docs/guide.html#read): string\n * - [safe](/docs/guide.html#safe): bool - defaults to true.\n * - [shardKey](/docs/guide.html#shardKey): bool - defaults to `null`\n * - [strict](/docs/guide.html#strict): bool - defaults to true\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\n * - [toObject](/docs/guide.html#toObject) - object - no default\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [useNestedStrict](/docs/guide.html#useNestedStrict) - boolean - defaults to false\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [versionKey](/docs/guide.html#versionKey): string - defaults to \"__v\"\n * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)\n *\n * ####Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object} definition\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = {};\n  this.statics = {};\n  this.tree = {};\n  this.query = {};\n  this.childSchemas = [];\n  this.plugins = [];\n\n  this.s = {\n    hooks: new Kareem(),\n    kareemHooks: IS_KAREEM_HOOK\n  };\n\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (obj) {\n    this.add(obj);\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  var _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  var auto_id = !this.paths['_id'] &&\n      (!this.options.noId && this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    var _obj = {_id: {auto: true}};\n    _obj._id[this.options.typeKey] = Schema.ObjectId;\n    this.add(_obj);\n  }\n\n  for (var i = 0; i < this._defaultMiddleware.length; ++i) {\n    var m = this._defaultMiddleware[i];\n    this[m.kind](m.hook, !!m.isAsync, m.fn);\n  }\n\n  if (this.options.timestamps) {\n    this.setupTimestamp(this.options.timestamps);\n  }\n\n  // Assign virtual properties based on alias option\n  aliasFields(this);\n}\n\n/*!\n * Create virtual properties with alias field\n */\nfunction aliasFields(schema) {\n  for (var path in schema.paths) {\n    if (!schema.paths[path].options) continue;\n\n    var prop = schema.paths[path].path;\n    var alias = schema.paths[path].options.alias;\n\n    if (alias) {\n      if ('string' === typeof alias && alias.length > 0) {\n        if (schema.aliases[alias]) {\n          throw new Error('Duplicate alias, alias ' + alias + ' is used more than once');\n        } else {\n          schema.aliases[alias] = prop;\n        }\n\n        schema\n          .virtual(alias)\n          .get((function(p) {\n            return function() {\n              if (typeof this.get === 'function') {\n                return this.get(p);\n              }\n              return this[p];\n            };\n          })(prop))\n          .set((function(p) {\n            return function(v) {\n              return this.set(p, v);\n            };\n          })(prop));\n      } else {\n        throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n      }\n    }\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/**\n * Default middleware attached to a schema. Cannot be changed.\n *\n * This field is used to make sure discriminators don't get multiple copies of\n * built-in middleware. Declared as a constant because changing this at runtime\n * may lead to instability with Model.prototype.discriminator().\n *\n * @api private\n * @property _defaultMiddleware\n */\nObject.defineProperty(Schema.prototype, '_defaultMiddleware', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: [\n    {\n      kind: 'pre',\n      hook: 'remove',\n      isAsync: true,\n      fn: function(next, done) {\n        if (this.ownerDocument) {\n          done();\n          next();\n          return;\n        }\n\n        var subdocs = this.$__getAllSubdocs();\n\n        if (!subdocs.length) {\n          done();\n          next();\n          return;\n        }\n\n        each(subdocs, function(subdoc, cb) {\n          subdoc.remove({ noop: true }, function(err) {\n            cb(err);\n          });\n        }, function(error) {\n          if (error) {\n            done(error);\n            return;\n          }\n          next();\n          done();\n        });\n      }\n    }\n  ]\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * ####Example:\n *\n *     var schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n */\n\nSchema.prototype.obj;\n\n/**\n * Schema as flat paths\n *\n * ####Example:\n *     {\n *         '_id'        : SchemaType,\n *       , 'nested.key' : SchemaType,\n *     }\n *\n * @api private\n * @property paths\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * ####Example:\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n */\n\nSchema.prototype.tree;\n\n/**\n * Returns a deep copy of the schema\n *\n * @return {Schema} the cloned schema\n * @api public\n */\n\nSchema.prototype.clone = function() {\n  var s = new Schema(this.paths, this.options);\n  // Clone the call queue\n  var cloneOpts = { retainKeyOrder: true };\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = utils.clone(this.methods, cloneOpts);\n  s.statics = utils.clone(this.statics, cloneOpts);\n  s.query = utils.clone(this.query, cloneOpts);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = utils.clone(this._indexes, cloneOpts);\n  s.s.hooks = this.s.hooks.clone();\n  return s;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  if (options && options.safe === false) {\n    options.safe = {w: 0};\n  }\n\n  if (options && options.safe && options.safe.w === 0) {\n    // if you turn off safe writes, then versioning goes off as well\n    options.versionKey = false;\n  }\n\n  this._userProvidedOptions = utils.clone(options, {\n    retainKeyOrder: true\n  });\n\n  options = utils.options({\n    strict: true,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    discriminatorKey: '__t',\n    minimize: true,\n    autoIndex: null,\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    // the following are only applied at construction time\n    noId: false, // deprecated, use { _id: false }\n    _id: true,\n    noVirtualId: false, // deprecated, use { id: false }\n    id: true,\n    typeKey: 'type',\n    retainKeyOrder: false\n  }, options);\n\n  if (options.read) {\n    options.read = readPref(options.read);\n  }\n\n  return options;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * ####Example:\n *\n *     var ToySchema = new Schema;\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n * @param {Object} obj\n * @param {String} prefix\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  prefix = prefix || '';\n  var keys = Object.keys(obj);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n\n    if (obj[key] == null) {\n      throw new TypeError('Invalid value for schema path `' + prefix + key + '`');\n    }\n\n    if (Array.isArray(obj[key]) && obj[key].length === 1 && obj[key][0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + prefix + key + '`');\n    }\n\n    if (utils.isObject(obj[key]) &&\n        (!obj[key].constructor || utils.getFunctionName(obj[key].constructor) === 'Object') &&\n        (!obj[key][this.options.typeKey] || (this.options.typeKey === 'type' && obj[key].type.type))) {\n      if (Object.keys(obj[key]).length) {\n        // nested object { last: { name: String }}\n        this.nested[prefix + key] = true;\n        this.add(obj[key], prefix + key + '.');\n      } else {\n        if (prefix) {\n          this.nested[prefix.substr(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, obj[key]); // mixed type\n      }\n    } else {\n      if (prefix) {\n        this.nested[prefix.substr(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, obj[key]);\n    }\n  }\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.\n *\n *      on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      var schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n */\n\nSchema.reserved = Object.create(null);\nvar reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.on =\nreserved.once =\nreserved.listeners =\nreserved.removeListener =\n// document properties and functions\nreserved.collection =\nreserved.db =\nreserved.errors =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.get =\nreserved.modelName =\nreserved.save =\nreserved.schema =\nreserved.toObject =\nreserved.validate =\nreserved.remove =\n// hooks.js\nreserved._pres = reserved._posts = 1;\n\n/*!\n * Document keys to print warnings for\n */\n\nvar warnings = {};\nwarnings.increment = '`increment` should not be used as a schema path name ' +\n    'unless you have disabled versioning.';\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * ####Example\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path\n * @param {Object} constructor\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  if (obj === undefined) {\n    if (this.paths[path]) {\n      return this.paths[path];\n    }\n    if (this.subpaths[path]) {\n      return this.subpaths[path];\n    }\n    if (this.singleNestedPaths[path]) {\n      return this.singleNestedPaths[path];\n    }\n\n    // subpaths?\n    return /\\.\\d+\\.?.*$/.test(path)\n        ? getPositionalPath(this, path)\n        : undefined;\n  }\n\n  // some path names conflict with document methods\n  if (reserved[path]) {\n    throw new Error('`' + path + '` may not be used as a schema pathname');\n  }\n\n  if (warnings[path]) {\n    console.log('WARN: ' + warnings[path]);\n  }\n\n  // update the tree\n  var subpaths = path.split(/\\./),\n      last = subpaths.pop(),\n      branch = this.tree;\n\n  subpaths.forEach(function(sub, i) {\n    if (!branch[sub]) {\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      var msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + subpaths.slice(0, i).concat([sub]).join('.')\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  });\n\n  branch[last] = utils.clone(obj);\n\n  this.paths[path] = Schema.interpretAsType(path, obj, this.options);\n\n  if (this.paths[path].$isSingleNested) {\n    for (var key in this.paths[path].schema.paths) {\n      this.singleNestedPaths[path + '.' + key] =\n          this.paths[path].schema.paths[key];\n    }\n    for (key in this.paths[path].schema.singleNestedPaths) {\n      this.singleNestedPaths[path + '.' + key] =\n          this.paths[path].schema.singleNestedPaths[key];\n    }\n\n    this.childSchemas.push({\n      schema: this.paths[path].schema,\n      model: this.paths[path].caster\n    });\n  } else if (this.paths[path].$isMongooseDocumentArray) {\n    this.childSchemas.push({\n      schema: this.paths[path].schema,\n      model: this.paths[path].casterConstructor\n    });\n  }\n  return this;\n};\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @api private\n */\n\nSchema.interpretAsType = function(path, obj, options) {\n  if (obj instanceof SchemaType) {\n    return obj;\n  }\n\n  if (obj.constructor) {\n    var constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      var oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  var type = obj[options.typeKey] && (options.typeKey !== 'type' || !obj.type.type)\n      ? obj[options.typeKey]\n      : {};\n\n  if (utils.getFunctionName(type.constructor) === 'Object' || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || Array === type || type === 'array') {\n    // if it was specified through { type } look for `cast`\n    var cast = (Array === type || type === 'array')\n        ? obj.cast\n        : type[0];\n\n    if (cast && cast.instanceOfSchema) {\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n    if (cast &&\n        cast[options.typeKey] &&\n        cast[options.typeKey].instanceOfSchema) {\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, Schema.interpretAsType(path, cast, options), obj);\n    }\n\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (cast && (!cast[options.typeKey] || (options.typeKey === 'type' && cast.type.type))\n        && utils.getFunctionName(cast.constructor) === 'Object') {\n      if (Object.keys(cast).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        var childSchemaOptions = {minimize: options.minimize};\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        //propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n        //propagate 'runSettersOnQuery' option to child schema\n        if (options.hasOwnProperty('runSettersOnQuery')) {\n          childSchemaOptions.runSettersOnQuery = options.runSettersOnQuery;\n        }\n        var childSchema = new Schema(cast, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n          ? cast[options.typeKey]\n          : cast;\n\n      name = typeof type === 'string'\n          ? type\n          : type.schemaName || utils.getFunctionName(type);\n\n      if (!(name in MongooseTypes)) {\n        throw new TypeError('Undefined type `' + name + '` at array `' + path +\n          '`');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Embedded(type, path, obj);\n  }\n\n  var name;\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else {\n    name = typeof type === 'string'\n        ? type\n      // If not string, `type` is a function. Outside of IE, function.name\n      // gives you the function name. In IE, you need to compute it\n        : type.schemaName || utils.getFunctionName(type);\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n\n  if (undefined == MongooseTypes[name]) {\n    throw new TypeError('Undefined type `' + name + '` at `' + path +\n        '`\\n  Did you try nesting Schemas? ' +\n        'You can only nest using refs or arrays.');\n  }\n\n  obj = utils.clone(obj, { retainKeyOrder: true });\n  if (!('runSettersOnQuery' in obj)) {\n    obj.runSettersOnQuery = options.runSettersOnQuery;\n  }\n  return new MongooseTypes[name](path, obj);\n};\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and schemaType as arguments on each iteration.\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  var keys = Object.keys(this.paths),\n      len = keys.length;\n\n  for (var i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * @api public\n * @param {Boolean} invalidate refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  var paths = Object.keys(this.paths),\n      i = paths.length,\n      ret = [];\n\n  while (i--) {\n    var path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  if (path in this.paths) {\n    return 'real';\n  }\n  if (path in this.virtuals) {\n    return 'virtual';\n  }\n  if (path in this.nested) {\n    return 'nested';\n  }\n  if (path in this.subpaths) {\n    return 'real';\n  }\n  if (path in this.singleNestedPaths) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  var subpaths = path.split(/\\./g);\n  path = '';\n  for (var i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (path in this.paths &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  if (timestamps) {\n    var createdAt = handleTimestampOption(timestamps, 'createdAt');\n    var updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n    var schemaAdditions = {};\n\n    if (updatedAt && !this.paths[updatedAt]) {\n      schemaAdditions[updatedAt] = Date;\n    }\n\n    if (createdAt && !this.paths[createdAt]) {\n      schemaAdditions[createdAt] = Date;\n    }\n\n    this.add(schemaAdditions);\n\n    this.pre('save', function(next) {\n      var defaultTimestamp = new Date();\n      var auto_id = this._id && this._id.auto;\n\n      if (createdAt != null && !this.get(createdAt) && this.isSelected(createdAt)) {\n        this.set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);\n      }\n\n      if (updatedAt != null && (this.isNew || this.isModified())) {\n        var ts = defaultTimestamp;\n        if (this.isNew) {\n          if (createdAt != null) {\n            ts = this.get(createdAt);\n          } else if (auto_id) {\n            ts = this._id.getTimestamp();\n          }\n        }\n        this.set(updatedAt, ts);\n      }\n\n      next();\n    });\n\n    var genUpdates = function(currentUpdate, overwrite) {\n      var now = new Date();\n      var updates = {};\n      var _updates = updates;\n      if (overwrite) {\n        if (currentUpdate && currentUpdate.$set) {\n          currentUpdate = currentUpdate.$set;\n          updates.$set = {};\n          _updates = updates.$set;\n        }\n        if (updatedAt != null && !currentUpdate[updatedAt]) {\n          _updates[updatedAt] = now;\n        }\n        if (createdAt != null && !currentUpdate[createdAt]) {\n          _updates[createdAt] = now;\n        }\n        return updates;\n      }\n      updates = { $set: {} };\n      currentUpdate = currentUpdate || {};\n\n      if (updatedAt != null &&\n          (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {\n        updates.$set[updatedAt] = now;\n      }\n\n      if (createdAt != null) {\n        if (currentUpdate[createdAt]) {\n          delete currentUpdate[createdAt];\n        }\n        if (currentUpdate.$set && currentUpdate.$set[createdAt]) {\n          delete currentUpdate.$set[createdAt];\n        }\n\n        updates.$setOnInsert = {};\n        updates.$setOnInsert[createdAt] = now;\n      }\n\n      return updates;\n    };\n\n    this.methods.initializeTimestamps = function() {\n      if (!this.get(createdAt)) {\n        this.set(createdAt, new Date());\n      }\n      if (!this.get(updatedAt)) {\n        this.set(updatedAt, new Date());\n      }\n      return this;\n    };\n\n    this.pre('findOneAndUpdate', function(next) {\n      var overwrite = this.options.overwrite;\n      this.findOneAndUpdate({}, genUpdates(this.getUpdate(), overwrite), {\n        overwrite: overwrite\n      });\n      applyTimestampsToChildren(this);\n      next();\n    });\n\n    this.pre('update', function(next) {\n      var overwrite = this.options.overwrite;\n      this.update({}, genUpdates(this.getUpdate(), overwrite), {\n        overwrite: overwrite\n      });\n      applyTimestampsToChildren(this);\n      next();\n    });\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleTimestampOption(arg, prop) {\n  if (typeof arg === 'boolean') {\n    return prop;\n  }\n  if (typeof arg[prop] === 'boolean') {\n    return arg[prop] ? prop : null;\n  }\n  if (!(prop in arg)) {\n    return prop;\n  }\n  return arg[prop];\n}\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToChildren(query) {\n  var now = new Date();\n  var update = query.getUpdate();\n  var keys = Object.keys(update);\n  var key;\n  var schema = query.model.schema;\n  var len;\n  var createdAt;\n  var updatedAt;\n  var timestamps;\n  var path;\n\n  var hasDollarKey = keys.length && keys[0].charAt(0) === '$';\n\n  if (hasDollarKey) {\n    if (update.$push) {\n      for (key in update.$push) {\n        var $path = schema.path(key);\n        if (update.$push[key] &&\n            $path &&\n            $path.$isMongooseDocumentArray &&\n            $path.schema.options.timestamps) {\n          timestamps = $path.schema.options.timestamps;\n          createdAt = handleTimestampOption(timestamps, 'createdAt');\n          updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n          if (update.$push[key].$each) {\n            update.$push[key].$each.forEach(function(subdoc) {\n              if (updatedAt != null) {\n                subdoc[updatedAt] = now;\n              }\n              if (createdAt != null) {\n                subdoc[createdAt] = now;\n              }\n            });\n          } else {\n            if (updatedAt != null) {\n              update.$push[key][updatedAt] = now;\n            }\n            if (createdAt != null) {\n              update.$push[key][createdAt] = now;\n            }\n          }\n        }\n      }\n    }\n    if (update.$set) {\n      for (key in update.$set) {\n        path = schema.path(key);\n        if (!path) {\n          continue;\n        }\n        if (Array.isArray(update.$set[key]) && path.$isMongooseDocumentArray) {\n          len = update.$set[key].length;\n          timestamps = schema.path(key).schema.options.timestamps;\n          if (timestamps) {\n            createdAt = handleTimestampOption(timestamps, 'createdAt');\n            updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n            for (var i = 0; i < len; ++i) {\n              if (updatedAt != null) {\n                update.$set[key][i][updatedAt] = now;\n              }\n              if (createdAt != null) {\n                update.$set[key][i][createdAt] = now;\n              }\n            }\n          }\n        } else if (update.$set[key] && path.$isSingleNested) {\n          timestamps = schema.path(key).schema.options.timestamps;\n          if (timestamps) {\n            createdAt = handleTimestampOption(timestamps, 'createdAt');\n            updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n            if (updatedAt != null) {\n              update.$set[key][updatedAt] = now;\n            }\n            if (createdAt != null) {\n              update.$set[key][createdAt] = now;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction getPositionalPathType(self, path) {\n  var subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths[subpaths[0]];\n  }\n\n  var val = self.path(subpaths[0]);\n  var isNested = false;\n  if (!val) {\n    return val;\n  }\n\n  var last = subpaths.length - 1,\n      subpath,\n      i = 1;\n\n  for (; i < subpaths.length; ++i) {\n    isNested = false;\n    subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        var oldVal = val;\n        val = new SchemaType(subpath);\n        val.cast = function(value, doc, init) {\n          return oldVal.cast(value, doc, init)[0];\n        };\n        val.caster = oldVal.caster;\n        val.schema = oldVal.schema;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    var type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[path] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path) {\n  getPositionalPathType(self, path);\n  return self.subpaths[path];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the document.\n *\n * ####Example\n *\n *     var toySchema = new Schema(..);\n *\n *     toySchema.pre('save', function (next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     })\n *\n *     toySchema.pre('validate', function (next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     })\n *\n * @param {String} method\n * @param {Function} callback\n * @see hooks.js https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3\n * @api public\n */\n\nSchema.prototype.pre = function() {\n  var name = arguments[0];\n  if (IS_KAREEM_HOOK[name]) {\n    this.s.hooks.pre.apply(this.s.hooks, arguments);\n    return this;\n  }\n  return this.queue('pre', arguments);\n};\n\n/**\n * Defines a post hook for the document\n *\n *     var schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you run a find query');\n *     });\n *\n *     var Model = mongoose.model('Model', schema);\n *\n *     var m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String} method name of the method to hook\n * @param {Function} fn callback\n * @see middleware http://mongoosejs.com/docs/middleware.html\n * @see hooks.js https://www.npmjs.com/package/hooks-fixed\n * @see kareem http://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(method, fn) {\n  if (IS_KAREEM_HOOK[method]) {\n    this.s.hooks.post.apply(this.s.hooks, arguments);\n    return this;\n  }\n  // assuming that all callbacks with arity < 2 are synchronous post hooks\n  if (fn.length < 2) {\n    return this.queue('on', [arguments[0], function(doc) {\n      return fn.call(doc, doc);\n    }]);\n  }\n\n  if (fn.length === 3) {\n    this.s.hooks.post(method + ':error', fn);\n    return this;\n  }\n\n  return this.queue('post', [arguments[0], function(next) {\n    // wrap original function so that the callback goes last,\n    // for compatibility with old code that is using synchronous post hooks\n    var _this = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n    fn.call(this, this, function(err) {\n      return next.apply(_this, [err].concat(args));\n    });\n  }]);\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * @param {Function} plugin callback\n * @param {Object} [opts]\n * @see plugins\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\n      'got \"' + (typeof fn) + '\"');\n  }\n\n  if (opts &&\n      opts.deduplicate) {\n    for (var i = 0; i < this.plugins.length; ++i) {\n      if (this.plugins[i].fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({ fn: fn, opts: opts });\n\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     var Kitty = mongoose.model('Kitty', schema);\n *\n *     var fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     fizz.purr();\n *     fizz.scratch();\n *\n * @param {String|Object} method name\n * @param {Function} [fn]\n * @api public\n */\n\nSchema.prototype.method = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (var i in name) {\n      this.methods[i] = name[i];\n    }\n  } else {\n    this.methods[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = new Schema(..);\n *     schema.static('findByName', function (name, callback) {\n *       return this.find({ name: name }, callback);\n *     });\n *\n *     var Drink = mongoose.model('Drink', schema);\n *     Drink.findByName('sanpellegrino', function (err, drinks) {\n *       //\n *     });\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name\n * @param {Function} [fn]\n * @api public\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (var i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * ####Example\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)\n * @param {String} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets/gets a schema option.\n *\n * ####Example\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key option name\n * @param {Object} [value] if not passed, the current option value is returned\n * @see Schema ./\n * @api public\n */\n\nSchema.prototype.set = function(key, value, _tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      this.options[key] = readPref(value, _tags);\n      break;\n    case 'safe':\n      this.options[key] = value === false\n          ? {w: 0}\n          : value;\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      break;\n    default:\n      this.options[key] = value;\n  }\n\n  return this;\n};\n\n/**\n * Gets a schema option.\n *\n * @param {String} key option name\n * @api public\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\n/**\n * The allowed index types\n *\n * @static indexTypes\n * @receiver Schema\n * @api public\n */\n\nvar indexTypes = '2d 2dsphere hashed text'.split(' ');\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()`\n * or by `index: true` in a path's options.\n *\n * @api public\n */\n\nSchema.prototype.indexes = function() {\n  'use strict';\n\n  var indexes = [];\n  var schemaStack = [];\n\n  var collectIndexes = function(schema, prefix) {\n    // Ignore infinitely nested schemas, if we've already seen this schema\n    // along this path there must be a cycle\n    if (schemaStack.indexOf(schema) !== -1) {\n      return;\n    }\n    schemaStack.push(schema);\n\n    prefix = prefix || '';\n    var key, path, index, field, isObject, options, type;\n    var keys = Object.keys(schema.paths);\n\n    for (var i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      path = schema.paths[key];\n\n      if ((path instanceof MongooseTypes.DocumentArray) || path.$isSingleNested) {\n        if (path.options.excludeIndexes !== true) {\n          collectIndexes(path.schema, prefix + key + '.');\n        }\n      } else {\n        index = path._index || (path.caster && path.caster._index);\n\n        if (index !== false && index !== null && index !== undefined) {\n          field = {};\n          isObject = utils.isObject(index);\n          options = isObject ? index : {};\n          type = typeof index === 'string' ? index :\n              isObject ? index.type :\n                  false;\n\n          if (type && ~Schema.indexTypes.indexOf(type)) {\n            field[prefix + key] = type;\n          } else if (options.text) {\n            field[prefix + key] = 'text';\n            delete options.text;\n          } else {\n            field[prefix + key] = 1;\n          }\n\n          delete options.type;\n          if (!('background' in options)) {\n            options.background = true;\n          }\n\n          indexes.push([field, options]);\n        }\n      }\n    }\n\n    schemaStack.pop();\n\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function(index) {\n        if (!('background' in index[1])) {\n          index[1].background = true;\n        }\n      });\n      indexes = indexes.concat(schema._indexes);\n    }\n  };\n\n  collectIndexes(this);\n  return indexes;\n\n  /*!\n   * Checks for indexes added to subdocs using Schema.index().\n   * These indexes need their paths prefixed properly.\n   *\n   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]\n   */\n\n  function fixSubIndexPaths(schema, prefix) {\n    var subindexes = schema._indexes,\n        len = subindexes.length,\n        indexObj,\n        newindex,\n        klen,\n        keys,\n        key,\n        i = 0,\n        j;\n\n    for (i = 0; i < len; ++i) {\n      indexObj = subindexes[i][0];\n      keys = Object.keys(indexObj);\n      klen = keys.length;\n      newindex = {};\n\n      // use forward iteration, order matters\n      for (j = 0; j < klen; ++j) {\n        key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n\n      indexes.push([newindex, subindexes[i][1]]);\n    }\n  }\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name\n * @param {Object} [options]\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (options && options.ref) {\n    if (!options.localField) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (!options.foreignField) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function(next, obj) {\n      if (mpath.has(name, obj)) {\n        var _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n      if (this.ownerDocument) {\n        next();\n        return this;\n      } else {\n        next();\n      }\n    });\n\n    var virtual = this.virtual(name);\n    virtual.options = options;\n    return virtual.\n      get(function() {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n        if (name in this.$$populatedVirtuals) {\n          return this.$$populatedVirtuals[name];\n        }\n        return null;\n      }).\n      set(function(_v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n\n          if (typeof this.$$populatedVirtuals[name] !== 'object') {\n            this.$$populatedVirtuals[name] = null;\n          }\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n\n          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {\n            return doc && typeof doc === 'object';\n          });\n        }\n      });\n  }\n\n  var virtuals = this.virtuals;\n  var parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n        ? new VirtualType(options, name)\n        : {});\n    return mem[part];\n  }, this.tree);\n\n  return virtuals[name];\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getVirtual = function(name) {\n  return _getVirtual(this, name);\n};\n\n/*!\n * ignore\n */\n\nfunction _getVirtual(schema, name) {\n  if (schema.virtuals[name]) {\n    return schema.virtuals[name];\n  }\n  var parts = name.split('.');\n  var cur = '';\n  var nestedSchemaPath = '';\n  for (var i = 0; i < parts.length; ++i) {\n    cur += (cur.length > 0 ? '.' : '') + parts[i];\n    if (schema.virtuals[cur]) {\n      if (i === parts.length - 1) {\n        schema.virtuals[cur].$nestedSchemaPath = nestedSchemaPath;\n        return schema.virtuals[cur];\n      }\n      continue;\n    } else if (schema.paths[cur] && schema.paths[cur].schema) {\n      schema = schema.paths[cur].schema;\n      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + cur;\n      cur = '';\n    } else {\n      return null;\n    }\n  }\n}\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name\n * @return {VirtualType}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return this.virtuals[name];\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * @param {String|Array} path\n *\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name)) {\n        delete this.paths[name];\n\n        var pieces = name.split('.');\n        var last = pieces.pop();\n        var branch = this.tree;\n        for (var i = 0; i < pieces.length; ++i) {\n          branch = branch[pieces[i]];\n        }\n        delete branch[last];\n      }\n    }, this);\n  }\n};\n\n/**\n * Loads an ES6 class into a schema. Maps setters + getters, static methods, and instance methods to schema virtuals, statics, and methods.\n *\n * @param {Function} model\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model));\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype)$/)) {\n        return;\n      }\n      var method = Object.getOwnPropertyDescriptor(model, name);\n      if (typeof method.value === 'function') {\n        this.static(name, method.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    var method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  var _this = this;\n  var pathschema = _this.path(path);\n  var resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    var p = parts.length + 1;\n    var foundschema;\n    var trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            var ret;\n            if (parts[p] === '$') {\n              if (p + 1 === parts.length) {\n                // comments.$\n                return foundschema;\n              }\n              // comments.$.comments.$.title\n              ret = search(parts.slice(p + 1), foundschema.schema);\n              if (ret) {\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                  !foundschema.schema.$isSingleNested;\n              }\n              return ret;\n            }\n            // this is the last path of the selector\n            ret = search(parts.slice(p), foundschema.schema);\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  var parts = path.split('.');\n  for (var i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  var _this = this;\n  var pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    var p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$') {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     var ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * ####Types:\n *\n * - [String](#schema-string-js)\n * - [Number](#schema-number-js)\n * - [Boolean](#schema-boolean-js) | Bool\n * - [Array](#schema-array-js)\n * - [Buffer](#schema-buffer-js)\n * - [Date](#schema-date-js)\n * - [ObjectId](#schema-objectid-js) | Oid\n * - [Mixed](#schema-mixed-js)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     var Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n"]},"metadata":{},"sourceType":"script"}