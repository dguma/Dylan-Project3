{"ast":null,"code":"'use strict';\n\nvar defineKey = require('../document/compile').defineKey;\n\nvar utils = require('../../utils');\n\nvar CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true\n};\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  if (model.base && model.base.options.applyPluginsToDiscriminators) {\n    model.base._applyPlugins(schema);\n  }\n\n  if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name + '\" can only be a discriminator of the root model');\n  }\n\n  var key = model.schema.options.discriminatorKey;\n  var baseSchemaAddition = {};\n  baseSchemaAddition[key] = {\n    default: void 0,\n    select: true,\n    set: function (newName) {\n      if (newName === name) {\n        return name;\n      }\n\n      throw new Error('Can\\'t set discriminator key \"' + key + '\", \"' + name + '\" !== \"' + newName + '\"');\n    },\n    $skipDiscriminatorCheck: true\n  };\n  baseSchemaAddition[key][model.schema.options.typeKey] = String;\n  model.schema.add(baseSchemaAddition);\n  defineKey(key, null, model.prototype, null, [key], model.schema.options);\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name + '\" cannot have field with name \"' + key + '\"');\n  }\n\n  function merge(schema, baseSchema) {\n    if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {\n      var originalSchema = schema;\n      utils.merge(schema, originalSchema, {\n        retainKeyOrder: true\n      });\n      delete schema.paths._id;\n      delete schema.tree._id;\n    }\n\n    utils.merge(schema, baseSchema, {\n      retainKeyOrder: true,\n      omit: {\n        discriminators: true\n      }\n    });\n    var obj = {};\n    obj[key] = {\n      default: name,\n      select: true,\n      set: function (newName) {\n        if (newName === name) {\n          return name;\n        }\n\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = String;\n    schema.add(obj);\n    schema.discriminatorMapping = {\n      key: key,\n      value: name,\n      isRoot: false\n    };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n\n    var toJSON = schema.options.toJSON;\n    var toObject = schema.options.toObject;\n    var _id = schema.options._id;\n    var id = schema.options.id;\n    var keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n\n    for (var i = 0; i < keys.length; ++i) {\n      var _key = keys[i];\n\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key + ' (can only modify ' + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') + ')');\n        }\n      }\n    }\n\n    schema.options = utils.clone(baseSchema.options);\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n\n    schema.options.id = id;\n    schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n    schema.plugins = Array.prototype.slice(baseSchema.plugins);\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue.slice(schema._defaultMiddleware.length));\n    schema._requiredpaths = undefined; // reset just in case Schema#requiredPaths() was called on either schema\n  } // merges base schema into new discriminator schema and sets new type field.\n\n\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = {\n      key: key,\n      value: null,\n      isRoot: true\n    };\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name]) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/mongoose/lib/services/model/discriminator.js"],"names":["defineKey","require","utils","CUSTOMIZABLE_DISCRIMINATOR_OPTIONS","toJSON","toObject","_id","id","module","exports","discriminator","model","name","schema","instanceOfSchema","Error","base","options","applyPluginsToDiscriminators","_applyPlugins","discriminatorMapping","isRoot","key","discriminatorKey","baseSchemaAddition","default","select","set","newName","$skipDiscriminatorCheck","typeKey","String","add","prototype","path","merge","baseSchema","paths","auto","originalSchema","retainKeyOrder","tree","omit","discriminators","obj","value","collection","keys","Object","i","length","_key","deepEqual","join","clone","s","hooks","plugins","Array","slice","callQueue","concat","_defaultMiddleware","_requiredpaths","undefined"],"mappings":"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","sourcesContent":["'use strict';\n\nvar defineKey = require('../document/compile').defineKey;\nvar utils = require('../../utils');\n\nvar CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true\n};\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  if (model.base && model.base.options.applyPluginsToDiscriminators) {\n    model.base._applyPlugins(schema);\n  }\n\n  if (model.schema.discriminatorMapping &&\n      !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name +\n        '\" can only be a discriminator of the root model');\n  }\n\n  var key = model.schema.options.discriminatorKey;\n\n  var baseSchemaAddition = {};\n  baseSchemaAddition[key] = {\n    default: void 0,\n    select: true,\n    set: function(newName) {\n      if (newName === name) {\n        return name;\n      }\n      throw new Error('Can\\'t set discriminator key \"' + key + '\", \"' +\n        name + '\" !== \"' + newName + '\"');\n    },\n    $skipDiscriminatorCheck: true\n  };\n  baseSchemaAddition[key][model.schema.options.typeKey] = String;\n  model.schema.add(baseSchemaAddition);\n  defineKey(key, null, model.prototype, null, [key], model.schema.options);\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name +\n        '\" cannot have field with name \"' + key + '\"');\n  }\n\n  function merge(schema, baseSchema) {\n    if (baseSchema.paths._id &&\n        baseSchema.paths._id.options &&\n        !baseSchema.paths._id.options.auto) {\n      var originalSchema = schema;\n      utils.merge(schema, originalSchema, { retainKeyOrder: true });\n      delete schema.paths._id;\n      delete schema.tree._id;\n    }\n    utils.merge(schema, baseSchema, {\n      retainKeyOrder: true,\n      omit: { discriminators: true }\n    });\n\n    var obj = {};\n    obj[key] = {\n      default: name,\n      select: true,\n      set: function(newName) {\n        if (newName === name) {\n          return name;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = String;\n    schema.add(obj);\n    schema.discriminatorMapping = {key: key, value: name, isRoot: false};\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n\n    var toJSON = schema.options.toJSON;\n    var toObject = schema.options.toObject;\n    var _id = schema.options._id;\n    var id = schema.options.id;\n\n    var keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n\n    for (var i = 0; i < keys.length; ++i) {\n      var _key = keys[i];\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key +\n              ' (can only modify ' +\n              Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +\n              ')');\n        }\n      }\n    }\n\n    schema.options = utils.clone(baseSchema.options);\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n    schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n\n    schema.plugins = Array.prototype.slice(baseSchema.plugins);\n    schema.callQueue = baseSchema.callQueue.\n      concat(schema.callQueue.slice(schema._defaultMiddleware.length));\n    schema._requiredpaths = undefined; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = {key: key, value: null, isRoot: true};\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name]) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};\n"]},"metadata":{},"sourceType":"script"}