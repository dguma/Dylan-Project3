{"ast":null,"code":"/*\n * provider.js: Abstraction providing an interface into pluggable configuration storage.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\nvar async = require('async'),\n    common = require('./common'); //\n// ### function Provider (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Provider object responsible\n// for exposing the pluggable storage features of `nconf`.\n//\n\n\nvar Provider = exports.Provider = function (options) {\n  //\n  // Setup default options for working with `stores`,\n  // `overrides`, `process.env` and `process.argv`.\n  //\n  options = options || {};\n  this.stores = {};\n  this.sources = [];\n  this.init(options);\n}; //\n// Define wrapper functions for using basic stores\n// in this instance\n//\n\n\n['argv', 'env'].forEach(function (type) {\n  Provider.prototype[type] = function () {\n    var args = [type].concat(Array.prototype.slice.call(arguments));\n    return this.add.apply(this, args);\n  };\n}); //\n// ### function file (key, options)\n// #### @key {string|Object} Fully qualified options, name of file store, or path.\n// #### @path {string|Object} **Optional** Full qualified options, or path.\n// Adds a new `File` store to this instance. Accepts the following options\n//\n//    nconf.file({ file: '.jitsuconf', dir: process.env.HOME, search: true });\n//    nconf.file('path/to/config/file');\n//    nconf.file('userconfig', 'path/to/config/file');\n//    nconf.file('userconfig', { file: '.jitsuconf', search: true });\n//\n\nProvider.prototype.file = function (key, options) {\n  if (arguments.length == 1) {\n    options = typeof key === 'string' ? {\n      file: key\n    } : key;\n    key = 'file';\n  } else {\n    options = typeof options === 'string' ? {\n      file: options\n    } : options;\n  }\n\n  options.type = 'file';\n  return this.add(key, options);\n}; //\n// Define wrapper functions for using\n// overrides and defaults\n//\n\n\n['defaults', 'overrides'].forEach(function (type) {\n  Provider.prototype[type] = function (options) {\n    options = options || {};\n\n    if (!options.type) {\n      options.type = 'literal';\n    }\n\n    return this.add(type, options);\n  };\n}); //\n// ### function use (name, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Adds (or replaces) a new store with the specified `name`\n// and `options`. If `options.type` is not set, then `name`\n// will be used instead:\n//\n//    provider.use('file');\n//    provider.use('file', { type: 'file', filename: '/path/to/userconf' })\n//\n\nProvider.prototype.use = function (name, options) {\n  options = options || {};\n  var type = options.type || name;\n\n  function sameOptions(store) {\n    return Object.keys(options).every(function (key) {\n      return options[key] === store[key];\n    });\n  }\n\n  var store = this.stores[name],\n      update = store && !sameOptions(store);\n\n  if (!store || update) {\n    if (update) {\n      this.remove(name);\n    }\n\n    this.add(name, options);\n  }\n\n  return this;\n}; //\n// ### function add (name, options)\n// #### @name {string} Name of the store to add to this instance\n// #### @options {Object} Options for the store to create\n// Adds a new store with the specified `name` and `options`. If `options.type`\n// is not set, then `name` will be used instead:\n//\n//    provider.add('memory');\n//    provider.add('userconf', { type: 'file', filename: '/path/to/userconf' })\n//\n\n\nProvider.prototype.add = function (name, options, usage) {\n  options = options || {};\n  var type = options.type || name;\n\n  if (!require('../nconf')[common.capitalize(type)]) {\n    throw new Error('Cannot add store with unknown type: ' + type);\n  }\n\n  this.stores[name] = this.create(type, options, usage);\n\n  if (this.stores[name].loadSync) {\n    this.stores[name].loadSync();\n  }\n\n  return this;\n}; //\n// ### function remove (name)\n// #### @name {string} Name of the store to remove from this instance\n// Removes a store with the specified `name` from this instance. Users\n// are allowed to pass in a type argument (e.g. `memory`) as name if\n// this was used in the call to `.add()`.\n//\n\n\nProvider.prototype.remove = function (name) {\n  delete this.stores[name];\n  return this;\n}; //\n// ### function create (type, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Creates a store of the specified `type` using the\n// specified `options`.\n//\n\n\nProvider.prototype.create = function (type, options, usage) {\n  return new (require('../nconf')[common.capitalize(type.toLowerCase())])(options, usage);\n}; //\n// ### function init (options)\n// #### @options {Object} Options to initialize this instance with.\n// Initializes this instance with additional `stores` or `sources` in the\n// `options` supplied.\n//\n\n\nProvider.prototype.init = function (options) {\n  var self = this; //\n  // Add any stores passed in through the options\n  // to this instance.\n  //\n\n  if (options.type) {\n    this.add(options.type, options);\n  } else if (options.store) {\n    this.add(options.store.name || options.store.type, options.store);\n  } else if (options.stores) {\n    Object.keys(options.stores).forEach(function (name) {\n      var store = options.stores[name];\n      self.add(store.name || name || store.type, store);\n    });\n  } //\n  // Add any read-only sources to this instance\n  //\n\n\n  if (options.source) {\n    this.sources.push(this.create(options.source.type || options.source.name, options.source));\n  } else if (options.sources) {\n    Object.keys(options.sources).forEach(function (name) {\n      var source = options.sources[name];\n      self.sources.push(self.create(source.type || source.name || name, source));\n    });\n  }\n}; //\n// ### function get (key, callback)\n// #### @key {string} Key to retrieve for this instance.\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the value for the specified key (if any).\n//\n\n\nProvider.prototype.get = function (key, callback) {\n  if (typeof key === 'function') {\n    // Allow a * key call to be made\n    callback = key;\n    key = null;\n  } //\n  // If there is no callback we can short-circuit into the default\n  // logic for traversing stores.\n  //\n\n\n  if (!callback) {\n    return this._execute('get', 1, key, callback);\n  } //\n  // Otherwise the asynchronous, hierarchical `get` is\n  // slightly more complicated because we do not need to traverse\n  // the entire set of stores, but up until there is a defined value.\n  //\n\n\n  var current = 0,\n      names = Object.keys(this.stores),\n      self = this,\n      response,\n      mergeObjs = [];\n  async.whilst(function () {\n    return typeof response === 'undefined' && current < names.length;\n  }, function (next) {\n    var store = self.stores[names[current]];\n    current++;\n\n    if (store.get.length >= 2) {\n      return store.get(key, function (err, value) {\n        if (err) {\n          return next(err);\n        }\n\n        response = value; // Merge objects if necessary\n\n        if (response && typeof response === 'object' && !Array.isArray(response)) {\n          mergeObjs.push(response);\n          response = undefined;\n        }\n\n        next();\n      });\n    }\n\n    response = store.get(key); // Merge objects if necessary\n\n    if (response && typeof response === 'object' && !Array.isArray(response)) {\n      mergeObjs.push(response);\n      response = undefined;\n    }\n\n    next();\n  }, function (err) {\n    if (!err && mergeObjs.length) {\n      response = common.merge(mergeObjs.reverse());\n    }\n\n    return err ? callback(err) : callback(null, response);\n  });\n}; //\n// ### function set (key, value, callback)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Sets the `value` for the specified `key` in this instance.\n//\n\n\nProvider.prototype.set = function (key, value, callback) {\n  return this._execute('set', 2, key, value, callback);\n}; //\n// ### function required (keys)\n// #### @keys {array} List of keys\n// Throws an error if any of `keys` has no value, otherwise returns `true`\n\n\nProvider.prototype.required = function (keys) {\n  if (!Array.isArray(keys)) {\n    throw new Error('Incorrect parameter, array expected');\n  }\n\n  var missing = [];\n  keys.forEach(function (key) {\n    if (typeof this.get(key) === 'undefined') {\n      missing.push(key);\n    }\n  }, this);\n\n  if (missing.length) {\n    throw new Error('Missing required keys: ' + missing.join(', '));\n  } else {\n    return true;\n  }\n}; //\n// ### function reset (callback)\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Clears all keys associated with this instance.\n//\n\n\nProvider.prototype.reset = function (callback) {\n  return this._execute('reset', 0, callback);\n}; //\n// ### function clear (key, callback)\n// #### @key {string} Key to remove from this instance\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Removes the value for the specified `key` from this instance.\n//\n\n\nProvider.prototype.clear = function (key, callback) {\n  return this._execute('clear', 1, key, callback);\n}; //\n// ### function merge ([key,] value [, callback])\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Merges the properties in `value` into the existing object value at `key`.\n//\n// 1. If the existing value `key` is not an Object, it will be completely overwritten.\n// 2. If `key` is not supplied, then the `value` will be merged into the root.\n//\n\n\nProvider.prototype.merge = function () {\n  var self = this,\n      args = Array.prototype.slice.call(arguments),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      value = args.pop(),\n      key = args.pop();\n\n  function mergeProperty(prop, next) {\n    return self._execute('merge', 2, prop, value[prop], next);\n  }\n\n  if (!key) {\n    if (Array.isArray(value) || typeof value !== 'object') {\n      return onError(new Error('Cannot merge non-Object into top-level.'), callback);\n    }\n\n    return async.forEach(Object.keys(value), mergeProperty, callback || function () {});\n  }\n\n  return this._execute('merge', 2, key, value, callback);\n}; //\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\n\n\nProvider.prototype.load = function (callback) {\n  var self = this;\n\n  function getStores() {\n    var stores = Object.keys(self.stores);\n    stores.reverse();\n    return stores.map(function (name) {\n      return self.stores[name];\n    });\n  }\n\n  function loadStoreSync(store) {\n    if (!store.loadSync) {\n      throw new Error('nconf store ' + store.type + ' has no loadSync() method');\n    }\n\n    return store.loadSync();\n  }\n\n  function loadStore(store, next) {\n    if (!store.load && !store.loadSync) {\n      return next(new Error('nconf store ' + store.type + ' has no load() method'));\n    }\n\n    return store.loadSync ? next(null, store.loadSync()) : store.load(next);\n  }\n\n  function loadBatch(targets, done) {\n    if (!done) {\n      return common.merge(targets.map(loadStoreSync));\n    }\n\n    async.map(targets, loadStore, function (err, objs) {\n      return err ? done(err) : done(null, common.merge(objs));\n    });\n  }\n\n  function mergeSources(data) {\n    //\n    // If `data` was returned then merge it into\n    // the system store.\n    //\n    if (data && typeof data === 'object') {\n      self.use('sources', {\n        type: 'literal',\n        store: data\n      });\n    }\n  }\n\n  function loadSources() {\n    var sourceHierarchy = self.sources.splice(0);\n    sourceHierarchy.reverse(); //\n    // If we don't have a callback and the current\n    // store is capable of loading synchronously\n    // then do so.\n    //\n\n    if (!callback) {\n      mergeSources(loadBatch(sourceHierarchy));\n      return loadBatch(getStores());\n    }\n\n    loadBatch(sourceHierarchy, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      mergeSources(data);\n      return loadBatch(getStores(), callback);\n    });\n  }\n\n  return self.sources.length ? loadSources() : loadBatch(getStores(), callback);\n}; //\n// ### function save (callback)\n// #### @callback {function} **optional**  Continuation to respond to when\n// complete.\n// Instructs each provider to save.  If a callback is provided, we will attempt\n// asynchronous saves on the providers, falling back to synchronous saves if\n// this isn't possible.  If a provider does not know how to save, it will be\n// ignored.  Returns an object consisting of all of the data which was\n// actually saved.\n//\n\n\nProvider.prototype.save = function (value, callback) {\n  if (!callback && typeof value === 'function') {\n    callback = value;\n    value = null;\n  }\n\n  var self = this,\n      names = Object.keys(this.stores);\n\n  function saveStoreSync(memo, name) {\n    var store = self.stores[name]; //\n    // If the `store` doesn't have a `saveSync` method,\n    // just ignore it and continue.\n    //\n\n    if (store.saveSync) {\n      var ret = store.saveSync();\n\n      if (typeof ret == 'object' && ret !== null) {\n        memo.push(ret);\n      }\n    }\n\n    return memo;\n  }\n\n  function saveStore(memo, name, next) {\n    var store = self.stores[name]; //\n    // If the `store` doesn't have a `save` or saveSync`\n    // method(s), just ignore it and continue.\n    //\n\n    if (store.save) {\n      return store.save(value, function (err, data) {\n        if (err) {\n          return next(err);\n        }\n\n        if (typeof data == 'object' && data !== null) {\n          memo.push(data);\n        }\n\n        next(null, memo);\n      });\n    } else if (store.saveSync) {\n      memo.push(store.saveSync());\n    }\n\n    next(null, memo);\n  } //\n  // If we don't have a callback and the current\n  // store is capable of saving synchronously\n  // then do so.\n  //\n\n\n  if (!callback) {\n    return common.merge(names.reduce(saveStoreSync, []));\n  }\n\n  async.reduce(names, [], saveStore, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n}; //\n// ### @private function _execute (action, syncLength, [arguments])\n// #### @action {string} Action to execute on `this.store`.\n// #### @syncLength {number} Function length of the sync version.\n// #### @arguments {Array} Arguments array to apply to the action\n// Executes the specified `action` on all stores for this instance, ensuring a callback supplied\n// to a synchronous store function is still invoked.\n//\n\n\nProvider.prototype._execute = function (action, syncLength\n/* [arguments] */\n) {\n  var args = Array.prototype.slice.call(arguments, 2),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      destructive = ['set', 'clear', 'merge', 'reset'].indexOf(action) !== -1,\n      self = this,\n      response,\n      mergeObjs = [],\n      keys = Object.keys(this.stores);\n\n  function runAction(name, next) {\n    var store = self.stores[name];\n\n    if (destructive && store.readOnly) {\n      return next();\n    }\n\n    return store[action].length > syncLength ? store[action].apply(store, args.concat(next)) : next(null, store[action].apply(store, args));\n  }\n\n  if (callback) {\n    return async.forEach(keys, runAction, function (err) {\n      return err ? callback(err) : callback();\n    });\n  }\n\n  keys.forEach(function (name) {\n    if (typeof response === 'undefined') {\n      var store = self.stores[name];\n\n      if (destructive && store.readOnly) {\n        return;\n      }\n\n      response = store[action].apply(store, args); // Merge objects if necessary\n\n      if (response && action === 'get' && typeof response === 'object' && !Array.isArray(response)) {\n        mergeObjs.push(response);\n        response = undefined;\n      }\n    }\n  });\n\n  if (mergeObjs.length) {\n    response = common.merge(mergeObjs.reverse());\n  }\n\n  return response;\n}; //\n// Throw the `err` if a callback is not supplied\n//\n\n\nfunction onError(err, callback) {\n  if (callback) {\n    return callback(err);\n  }\n\n  throw err;\n}","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/nconf/lib/nconf/provider.js"],"names":["async","require","common","Provider","exports","options","stores","sources","init","forEach","type","prototype","args","concat","Array","slice","call","arguments","add","apply","file","key","length","use","name","sameOptions","store","Object","keys","every","update","remove","usage","capitalize","Error","create","loadSync","toLowerCase","self","source","push","get","callback","_execute","current","names","response","mergeObjs","whilst","next","err","value","isArray","undefined","merge","reverse","set","required","missing","join","reset","clear","pop","mergeProperty","prop","onError","load","getStores","map","loadStoreSync","loadStore","loadBatch","targets","done","objs","mergeSources","data","loadSources","sourceHierarchy","splice","save","saveStoreSync","memo","saveSync","ret","saveStore","reduce","action","syncLength","destructive","indexOf","runAction","readOnly"],"mappings":"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","sourcesContent":["/*\n * provider.js: Abstraction providing an interface into pluggable configuration storage.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar async = require('async'),\n    common = require('./common');\n\n//\n// ### function Provider (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Provider object responsible\n// for exposing the pluggable storage features of `nconf`.\n//\nvar Provider = exports.Provider = function (options) {\n  //\n  // Setup default options for working with `stores`,\n  // `overrides`, `process.env` and `process.argv`.\n  //\n  options       = options || {};\n  this.stores  = {};\n  this.sources = [];\n  this.init(options);\n};\n\n//\n// Define wrapper functions for using basic stores\n// in this instance\n//\n\n['argv', 'env'].forEach(function (type) {\n  Provider.prototype[type] = function () {\n    var args = [type].concat(Array.prototype.slice.call(arguments));\n    return this.add.apply(this, args);\n  };\n});\n\n//\n// ### function file (key, options)\n// #### @key {string|Object} Fully qualified options, name of file store, or path.\n// #### @path {string|Object} **Optional** Full qualified options, or path.\n// Adds a new `File` store to this instance. Accepts the following options\n//\n//    nconf.file({ file: '.jitsuconf', dir: process.env.HOME, search: true });\n//    nconf.file('path/to/config/file');\n//    nconf.file('userconfig', 'path/to/config/file');\n//    nconf.file('userconfig', { file: '.jitsuconf', search: true });\n//\nProvider.prototype.file = function (key, options) {\n  if (arguments.length == 1) {\n    options = typeof key === 'string' ? { file: key } : key;\n    key = 'file';\n  }\n  else {\n    options = typeof options === 'string'\n      ? { file: options }\n      : options;\n  }\n\n  options.type = 'file';\n  return this.add(key, options);\n};\n\n//\n// Define wrapper functions for using\n// overrides and defaults\n//\n['defaults', 'overrides'].forEach(function (type) {\n  Provider.prototype[type] = function (options) {\n    options = options || {};\n    if (!options.type) {\n      options.type = 'literal';\n    }\n\n    return this.add(type, options);\n  };\n});\n\n//\n// ### function use (name, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Adds (or replaces) a new store with the specified `name`\n// and `options`. If `options.type` is not set, then `name`\n// will be used instead:\n//\n//    provider.use('file');\n//    provider.use('file', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.use = function (name, options) {\n  options  = options      || {};\n  var type = options.type || name;\n\n  function sameOptions (store) {\n    return Object.keys(options).every(function (key) {\n      return options[key] === store[key];\n    });\n  }\n\n  var store = this.stores[name],\n      update = store && !sameOptions(store);\n\n  if (!store || update) {\n    if (update) {\n      this.remove(name);\n    }\n\n    this.add(name, options);\n  }\n\n  return this;\n};\n\n//\n// ### function add (name, options)\n// #### @name {string} Name of the store to add to this instance\n// #### @options {Object} Options for the store to create\n// Adds a new store with the specified `name` and `options`. If `options.type`\n// is not set, then `name` will be used instead:\n//\n//    provider.add('memory');\n//    provider.add('userconf', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.add = function (name, options, usage) {\n  options  = options      || {};\n  var type = options.type || name;\n\n  if (!require('../nconf')[common.capitalize(type)]) {\n    throw new Error('Cannot add store with unknown type: ' + type);\n  }\n\n  this.stores[name] = this.create(type, options, usage);\n\n  if (this.stores[name].loadSync) {\n    this.stores[name].loadSync();\n  }\n\n  return this;\n};\n\n//\n// ### function remove (name)\n// #### @name {string} Name of the store to remove from this instance\n// Removes a store with the specified `name` from this instance. Users\n// are allowed to pass in a type argument (e.g. `memory`) as name if\n// this was used in the call to `.add()`.\n//\nProvider.prototype.remove = function (name) {\n  delete this.stores[name];\n  return this;\n};\n\n//\n// ### function create (type, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Creates a store of the specified `type` using the\n// specified `options`.\n//\nProvider.prototype.create = function (type, options, usage) {\n  return new (require('../nconf')[common.capitalize(type.toLowerCase())])(options, usage);\n};\n\n//\n// ### function init (options)\n// #### @options {Object} Options to initialize this instance with.\n// Initializes this instance with additional `stores` or `sources` in the\n// `options` supplied.\n//\nProvider.prototype.init = function (options) {\n  var self = this;\n\n  //\n  // Add any stores passed in through the options\n  // to this instance.\n  //\n  if (options.type) {\n    this.add(options.type, options);\n  }\n  else if (options.store) {\n    this.add(options.store.name || options.store.type, options.store);\n  }\n  else if (options.stores) {\n    Object.keys(options.stores).forEach(function (name) {\n      var store = options.stores[name];\n      self.add(store.name || name || store.type, store);\n    });\n  }\n\n  //\n  // Add any read-only sources to this instance\n  //\n  if (options.source) {\n    this.sources.push(this.create(options.source.type || options.source.name, options.source));\n  }\n  else if (options.sources) {\n    Object.keys(options.sources).forEach(function (name) {\n      var source = options.sources[name];\n      self.sources.push(self.create(source.type || source.name || name, source));\n    });\n  }\n};\n\n//\n// ### function get (key, callback)\n// #### @key {string} Key to retrieve for this instance.\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the value for the specified key (if any).\n//\nProvider.prototype.get = function (key, callback) {\n  if (typeof key === 'function') {\n    // Allow a * key call to be made\n    callback = key;\n    key = null;\n  }\n\n  //\n  // If there is no callback we can short-circuit into the default\n  // logic for traversing stores.\n  //\n  if (!callback) {\n    return this._execute('get', 1, key, callback);\n  }\n\n  //\n  // Otherwise the asynchronous, hierarchical `get` is\n  // slightly more complicated because we do not need to traverse\n  // the entire set of stores, but up until there is a defined value.\n  //\n  var current = 0,\n      names = Object.keys(this.stores),\n      self = this,\n      response,\n      mergeObjs = [];\n\n  async.whilst(function () {\n    return typeof response === 'undefined' && current < names.length;\n  }, function (next) {\n    var store = self.stores[names[current]];\n    current++;\n\n    if (store.get.length >= 2) {\n      return store.get(key, function (err, value) {\n        if (err) {\n          return next(err);\n        }\n\n        response = value;\n\n        // Merge objects if necessary\n        if (response && typeof response === 'object' && !Array.isArray(response)) {\n          mergeObjs.push(response);\n          response = undefined;\n        }\n\n        next();\n      });\n    }\n\n    response = store.get(key);\n\n    // Merge objects if necessary\n    if (response && typeof response === 'object' && !Array.isArray(response)) {\n      mergeObjs.push(response);\n      response = undefined;\n    }\n\n    next();\n  }, function (err) {\n    if (!err && mergeObjs.length) {\n      response = common.merge(mergeObjs.reverse());\n    }\n    return err ? callback(err) : callback(null, response);\n  });\n};\n\n//\n// ### function set (key, value, callback)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Sets the `value` for the specified `key` in this instance.\n//\nProvider.prototype.set = function (key, value, callback) {\n  return this._execute('set', 2, key, value, callback);\n};\n\n\n//\n// ### function required (keys)\n// #### @keys {array} List of keys\n// Throws an error if any of `keys` has no value, otherwise returns `true`\nProvider.prototype.required = function (keys) {\n  if (!Array.isArray(keys)) {\n    throw new Error('Incorrect parameter, array expected');\n  }\n\n  var missing = [];\n  keys.forEach(function(key) {\n    if (typeof this.get(key) === 'undefined') {\n      missing.push(key);\n    }\n  }, this);\n\n  if (missing.length) {\n    throw new Error('Missing required keys: ' + missing.join(', '));\n  } else {\n    return true;\n  }\n\n};\n\n//\n// ### function reset (callback)\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Clears all keys associated with this instance.\n//\nProvider.prototype.reset = function (callback) {\n  return this._execute('reset', 0, callback);\n};\n\n//\n// ### function clear (key, callback)\n// #### @key {string} Key to remove from this instance\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Removes the value for the specified `key` from this instance.\n//\nProvider.prototype.clear = function (key, callback) {\n  return this._execute('clear', 1, key, callback);\n};\n\n//\n// ### function merge ([key,] value [, callback])\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Merges the properties in `value` into the existing object value at `key`.\n//\n// 1. If the existing value `key` is not an Object, it will be completely overwritten.\n// 2. If `key` is not supplied, then the `value` will be merged into the root.\n//\nProvider.prototype.merge = function () {\n  var self = this,\n      args = Array.prototype.slice.call(arguments),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      value = args.pop(),\n      key = args.pop();\n\n  function mergeProperty (prop, next) {\n    return self._execute('merge', 2, prop, value[prop], next);\n  }\n\n  if (!key) {\n    if (Array.isArray(value) || typeof value !== 'object') {\n      return onError(new Error('Cannot merge non-Object into top-level.'), callback);\n    }\n\n    return async.forEach(Object.keys(value), mergeProperty, callback || function () { })\n  }\n\n  return this._execute('merge', 2, key, value, callback);\n};\n\n//\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\nProvider.prototype.load = function (callback) {\n  var self = this;\n\n  function getStores () {\n    var stores = Object.keys(self.stores);\n    stores.reverse();\n    return stores.map(function (name) {\n      return self.stores[name];\n    });\n  }\n\n  function loadStoreSync(store) {\n    if (!store.loadSync) {\n      throw new Error('nconf store ' + store.type + ' has no loadSync() method');\n    }\n\n    return store.loadSync();\n  }\n\n  function loadStore(store, next) {\n    if (!store.load && !store.loadSync) {\n      return next(new Error('nconf store ' + store.type + ' has no load() method'));\n    }\n\n    return store.loadSync\n      ? next(null, store.loadSync())\n      : store.load(next);\n  }\n\n  function loadBatch (targets, done) {\n    if (!done) {\n      return common.merge(targets.map(loadStoreSync));\n    }\n\n    async.map(targets, loadStore, function (err, objs) {\n      return err ? done(err) : done(null, common.merge(objs));\n    });\n  }\n\n  function mergeSources (data) {\n    //\n    // If `data` was returned then merge it into\n    // the system store.\n    //\n    if (data && typeof data === 'object') {\n      self.use('sources', {\n        type: 'literal',\n        store: data\n      });\n    }\n  }\n\n  function loadSources () {\n    var sourceHierarchy = self.sources.splice(0);\n    sourceHierarchy.reverse();\n\n    //\n    // If we don't have a callback and the current\n    // store is capable of loading synchronously\n    // then do so.\n    //\n    if (!callback) {\n      mergeSources(loadBatch(sourceHierarchy));\n      return loadBatch(getStores());\n    }\n\n    loadBatch(sourceHierarchy, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      mergeSources(data);\n      return loadBatch(getStores(), callback);\n    });\n  }\n\n  return self.sources.length\n    ? loadSources()\n    : loadBatch(getStores(), callback);\n};\n\n//\n// ### function save (callback)\n// #### @callback {function} **optional**  Continuation to respond to when\n// complete.\n// Instructs each provider to save.  If a callback is provided, we will attempt\n// asynchronous saves on the providers, falling back to synchronous saves if\n// this isn't possible.  If a provider does not know how to save, it will be\n// ignored.  Returns an object consisting of all of the data which was\n// actually saved.\n//\nProvider.prototype.save = function (value, callback) {\n  if (!callback && typeof value === 'function') {\n    callback = value;\n    value = null;\n  }\n\n  var self = this,\n      names = Object.keys(this.stores);\n\n  function saveStoreSync(memo, name) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `saveSync` method,\n    // just ignore it and continue.\n    //\n    if (store.saveSync) {\n      var ret = store.saveSync();\n      if (typeof ret == 'object' && ret !== null) {\n        memo.push(ret);\n      }\n    }\n    return memo;\n  }\n\n  function saveStore(memo, name, next) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `save` or saveSync`\n    // method(s), just ignore it and continue.\n    //\n\n    if (store.save) {\n      return store.save(value, function (err, data) {\n        if (err) {\n          return next(err);\n        }\n\n        if (typeof data == 'object' && data !== null) {\n          memo.push(data);\n        }\n\n        next(null, memo);\n      });\n    }\n    else if (store.saveSync) {\n      memo.push(store.saveSync());\n    }\n\n    next(null, memo);\n  }\n\n  //\n  // If we don't have a callback and the current\n  // store is capable of saving synchronously\n  // then do so.\n  //\n  if (!callback) {\n    return common.merge(names.reduce(saveStoreSync, []));\n  }\n\n  async.reduce(names, [], saveStore, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n};\n\n//\n// ### @private function _execute (action, syncLength, [arguments])\n// #### @action {string} Action to execute on `this.store`.\n// #### @syncLength {number} Function length of the sync version.\n// #### @arguments {Array} Arguments array to apply to the action\n// Executes the specified `action` on all stores for this instance, ensuring a callback supplied\n// to a synchronous store function is still invoked.\n//\nProvider.prototype._execute = function (action, syncLength /* [arguments] */) {\n  var args = Array.prototype.slice.call(arguments, 2),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      destructive = ['set', 'clear', 'merge', 'reset'].indexOf(action) !== -1,\n      self = this,\n      response,\n      mergeObjs = [],\n      keys = Object.keys(this.stores);\n\n\n  function runAction (name, next) {\n    var store = self.stores[name];\n\n    if (destructive && store.readOnly) {\n      return next();\n    }\n\n    return store[action].length > syncLength\n      ? store[action].apply(store, args.concat(next))\n      : next(null, store[action].apply(store, args));\n  }\n\n  if (callback) {\n    return async.forEach(keys, runAction, function (err) {\n      return err ? callback(err) : callback();\n    });\n  }\n\n  keys.forEach(function (name) {\n    if (typeof response === 'undefined') {\n      var store = self.stores[name];\n\n      if (destructive && store.readOnly) {\n        return;\n      }\n\n      response = store[action].apply(store, args);\n\n      // Merge objects if necessary\n      if (response && action === 'get' && typeof response === 'object' && !Array.isArray(response)) {\n        mergeObjs.push(response);\n        response = undefined;\n      }\n    }\n  });\n\n  if (mergeObjs.length) {\n    response = common.merge(mergeObjs.reverse());\n  }\n\n  return response;\n}\n\n//\n// Throw the `err` if a callback is not supplied\n//\nfunction onError(err, callback) {\n  if (callback) {\n    return callback(err);\n  }\n\n  throw err;\n}\n"]},"metadata":{},"sourceType":"script"}