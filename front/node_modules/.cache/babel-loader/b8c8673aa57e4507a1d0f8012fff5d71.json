{"ast":null,"code":"/*!\n * Module requirements.\n */\nvar MongooseError = require('../error');\n\nvar utils = require('../utils');\n\nvar SchemaType = require('../schematype');\n\nvar CastError = SchemaType.CastError;\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nSchemaDate.schemaName = 'Date';\n/*!\n * Inherits from SchemaType.\n */\n\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     var schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function (when) {\n  if (!this._index || this._index.constructor.name !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\n\nSchemaDate.prototype.checkRequired = function (value) {\n  return value instanceof Date;\n};\n/**\n * Sets a minimum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     var schema = new Schema({ d: { type: Date, min: min })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\n\nSchemaDate.prototype.min = function (value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function (v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    var msg = message || MongooseError.messages.Date.min;\n    msg = msg.replace(/{MIN}/, value === Date.now ? 'Date.now()' : this.cast(value).toString());\n\n    var _this = this;\n\n    this.validators.push({\n      validator: this.minValidator = function (val) {\n        var min = value === Date.now ? value() : _this.cast(value);\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n/**\n * Sets a maximum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     var schema = new Schema({ d: { type: Date, max: max })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\n\nSchemaDate.prototype.max = function (value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function (v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    var msg = message || MongooseError.messages.Date.max;\n    msg = msg.replace(/{MAX}/, value === Date.now ? 'Date.now()' : this.cast(value).toString());\n\n    var _this = this;\n\n    this.validators.push({\n      validator: this.maxValidator = function (val) {\n        var max = value === Date.now ? value() : _this.cast(value);\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\n\nSchemaDate.prototype.cast = function (value) {\n  // If null or undefined\n  if (value === null || value === void 0 || value === '') {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    if (isNaN(value.valueOf())) {\n      throw new CastError('date', value, this.path);\n    }\n\n    return value;\n  }\n\n  var date;\n\n  if (typeof value === 'boolean') {\n    throw new CastError('date', value, this.path);\n  }\n\n  if (value instanceof Number || typeof value === 'number' || String(value) == Number(value)) {\n    // support for timestamps\n    date = new Date(Number(value));\n  } else if (value.valueOf) {\n    // support for moment.js\n    date = new Date(value.valueOf());\n  }\n\n  if (!isNaN(date.valueOf())) {\n    return date;\n  }\n\n  throw new CastError('date', value, this.path);\n};\n/*!\n * Date Query casting.\n *\n * @api private\n */\n\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDate.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n});\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function ($conditional, val) {\n  var handler;\n\n  if (arguments.length !== 2) {\n    return this._castForQuery($conditional);\n  }\n\n  handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n/*!\n * Module exports.\n */\n\n\nmodule.exports = SchemaDate;","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/mongoose/lib/schema/date.js"],"names":["MongooseError","require","utils","SchemaType","CastError","SchemaDate","key","options","call","schemaName","prototype","Object","create","constructor","expires","when","_index","name","checkRequired","value","Date","min","message","minValidator","validators","filter","v","validator","msg","messages","replace","now","cast","toString","_this","push","val","valueOf","type","max","maxValidator","isNaN","path","date","Number","String","handleSingle","$conditionalHandlers","$gt","$gte","$lt","$lte","castForQuery","$conditional","handler","arguments","length","_castForQuery","Error","module","exports"],"mappings":"AAAA;AACA;AACA;AAEA,IAAIA,aAAa,GAAGC,OAAO,CAAC,UAAD,CAA3B;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,UAAD,CAAnB;;AAEA,IAAIE,UAAU,GAAGF,OAAO,CAAC,eAAD,CAAxB;;AAEA,IAAIG,SAAS,GAAGD,UAAU,CAACC,SAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,UAAT,CAAoBC,GAApB,EAAyBC,OAAzB,EAAkC;AAChCJ,EAAAA,UAAU,CAACK,IAAX,CAAgB,IAAhB,EAAsBF,GAAtB,EAA2BC,OAA3B,EAAoC,MAApC;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACAF,UAAU,CAACI,UAAX,GAAwB,MAAxB;AAEA;AACA;AACA;;AACAJ,UAAU,CAACK,SAAX,GAAuBC,MAAM,CAACC,MAAP,CAAcT,UAAU,CAACO,SAAzB,CAAvB;AACAL,UAAU,CAACK,SAAX,CAAqBG,WAArB,GAAmCR,UAAnC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA,UAAU,CAACK,SAAX,CAAqBI,OAArB,GAA+B,UAASC,IAAT,EAAe;AAC5C,MAAI,CAAC,KAAKC,MAAN,IAAgB,KAAKA,MAAL,CAAYH,WAAZ,CAAwBI,IAAxB,KAAiC,QAArD,EAA+D;AAC7D,SAAKD,MAAL,GAAc,EAAd;AACD;;AAED,OAAKA,MAAL,CAAYF,OAAZ,GAAsBC,IAAtB;AACAb,EAAAA,KAAK,CAACY,OAAN,CAAc,KAAKE,MAAnB;AACA,SAAO,IAAP;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAX,UAAU,CAACK,SAAX,CAAqBQ,aAArB,GAAqC,UAASC,KAAT,EAAgB;AACnD,SAAOA,KAAK,YAAYC,IAAxB;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAf,UAAU,CAACK,SAAX,CAAqBW,GAArB,GAA2B,UAASF,KAAT,EAAgBG,OAAhB,EAAyB;AAClD,MAAI,KAAKC,YAAT,EAAuB;AACrB,SAAKC,UAAL,GAAkB,KAAKA,UAAL,CAAgBC,MAAhB,CAAuB,UAASC,CAAT,EAAY;AACnD,aAAOA,CAAC,CAACC,SAAF,KAAgB,KAAKJ,YAA5B;AACD,KAFiB,EAEf,IAFe,CAAlB;AAGD;;AAED,MAAIJ,KAAJ,EAAW;AACT,QAAIS,GAAG,GAAGN,OAAO,IAAItB,aAAa,CAAC6B,QAAd,CAAuBT,IAAvB,CAA4BC,GAAjD;AACAO,IAAAA,GAAG,GAAGA,GAAG,CAACE,OAAJ,CAAY,OAAZ,EAAsBX,KAAK,KAAKC,IAAI,CAACW,GAAf,GAAqB,YAArB,GAAoC,KAAKC,IAAL,CAAUb,KAAV,EAAiBc,QAAjB,EAA1D,CAAN;;AACA,QAAIC,KAAK,GAAG,IAAZ;;AACA,SAAKV,UAAL,CAAgBW,IAAhB,CAAqB;AACnBR,MAAAA,SAAS,EAAE,KAAKJ,YAAL,GAAoB,UAASa,GAAT,EAAc;AAC3C,YAAIf,GAAG,GAAIF,KAAK,KAAKC,IAAI,CAACW,GAAf,GAAqBZ,KAAK,EAA1B,GAA+Be,KAAK,CAACF,IAAN,CAAWb,KAAX,CAA1C;AACA,eAAOiB,GAAG,KAAK,IAAR,IAAgBA,GAAG,CAACC,OAAJ,MAAiBhB,GAAG,CAACgB,OAAJ,EAAxC;AACD,OAJkB;AAKnBf,MAAAA,OAAO,EAAEM,GALU;AAMnBU,MAAAA,IAAI,EAAE,KANa;AAOnBjB,MAAAA,GAAG,EAAEF;AAPc,KAArB;AASD;;AAED,SAAO,IAAP;AACD,CAvBD;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAd,UAAU,CAACK,SAAX,CAAqB6B,GAArB,GAA2B,UAASpB,KAAT,EAAgBG,OAAhB,EAAyB;AAClD,MAAI,KAAKkB,YAAT,EAAuB;AACrB,SAAKhB,UAAL,GAAkB,KAAKA,UAAL,CAAgBC,MAAhB,CAAuB,UAASC,CAAT,EAAY;AACnD,aAAOA,CAAC,CAACC,SAAF,KAAgB,KAAKa,YAA5B;AACD,KAFiB,EAEf,IAFe,CAAlB;AAGD;;AAED,MAAIrB,KAAJ,EAAW;AACT,QAAIS,GAAG,GAAGN,OAAO,IAAItB,aAAa,CAAC6B,QAAd,CAAuBT,IAAvB,CAA4BmB,GAAjD;AACAX,IAAAA,GAAG,GAAGA,GAAG,CAACE,OAAJ,CAAY,OAAZ,EAAsBX,KAAK,KAAKC,IAAI,CAACW,GAAf,GAAqB,YAArB,GAAoC,KAAKC,IAAL,CAAUb,KAAV,EAAiBc,QAAjB,EAA1D,CAAN;;AACA,QAAIC,KAAK,GAAG,IAAZ;;AACA,SAAKV,UAAL,CAAgBW,IAAhB,CAAqB;AACnBR,MAAAA,SAAS,EAAE,KAAKa,YAAL,GAAoB,UAASJ,GAAT,EAAc;AAC3C,YAAIG,GAAG,GAAIpB,KAAK,KAAKC,IAAI,CAACW,GAAf,GAAqBZ,KAAK,EAA1B,GAA+Be,KAAK,CAACF,IAAN,CAAWb,KAAX,CAA1C;AACA,eAAOiB,GAAG,KAAK,IAAR,IAAgBA,GAAG,CAACC,OAAJ,MAAiBE,GAAG,CAACF,OAAJ,EAAxC;AACD,OAJkB;AAKnBf,MAAAA,OAAO,EAAEM,GALU;AAMnBU,MAAAA,IAAI,EAAE,KANa;AAOnBC,MAAAA,GAAG,EAAEpB;AAPc,KAArB;AASD;;AAED,SAAO,IAAP;AACD,CAvBD;AAyBA;AACA;AACA;AACA;AACA;AACA;;;AAEAd,UAAU,CAACK,SAAX,CAAqBsB,IAArB,GAA4B,UAASb,KAAT,EAAgB;AAC1C;AACA,MAAIA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,IAAsCA,KAAK,KAAK,EAApD,EAAwD;AACtD,WAAO,IAAP;AACD;;AAED,MAAIA,KAAK,YAAYC,IAArB,EAA2B;AACzB,QAAIqB,KAAK,CAACtB,KAAK,CAACkB,OAAN,EAAD,CAAT,EAA4B;AAC1B,YAAM,IAAIjC,SAAJ,CAAc,MAAd,EAAsBe,KAAtB,EAA6B,KAAKuB,IAAlC,CAAN;AACD;;AAED,WAAOvB,KAAP;AACD;;AAED,MAAIwB,IAAJ;;AAEA,MAAI,OAAOxB,KAAP,KAAiB,SAArB,EAAgC;AAC9B,UAAM,IAAIf,SAAJ,CAAc,MAAd,EAAsBe,KAAtB,EAA6B,KAAKuB,IAAlC,CAAN;AACD;;AAED,MAAIvB,KAAK,YAAYyB,MAAjB,IAA2B,OAAOzB,KAAP,KAAiB,QAA5C,IACG0B,MAAM,CAAC1B,KAAD,CAAN,IAAiByB,MAAM,CAACzB,KAAD,CAD9B,EACuC;AACrC;AACAwB,IAAAA,IAAI,GAAG,IAAIvB,IAAJ,CAASwB,MAAM,CAACzB,KAAD,CAAf,CAAP;AACD,GAJD,MAIO,IAAIA,KAAK,CAACkB,OAAV,EAAmB;AACxB;AACAM,IAAAA,IAAI,GAAG,IAAIvB,IAAJ,CAASD,KAAK,CAACkB,OAAN,EAAT,CAAP;AACD;;AAED,MAAI,CAACI,KAAK,CAACE,IAAI,CAACN,OAAL,EAAD,CAAV,EAA4B;AAC1B,WAAOM,IAAP;AACD;;AAED,QAAM,IAAIvC,SAAJ,CAAc,MAAd,EAAsBe,KAAtB,EAA6B,KAAKuB,IAAlC,CAAN;AACD,CAlCD;AAoCA;AACA;AACA;AACA;AACA;;;AAEA,SAASI,YAAT,CAAsBV,GAAtB,EAA2B;AACzB,SAAO,KAAKJ,IAAL,CAAUI,GAAV,CAAP;AACD;;AAED/B,UAAU,CAACK,SAAX,CAAqBqC,oBAArB,GACI7C,KAAK,CAACK,OAAN,CAAcJ,UAAU,CAACO,SAAX,CAAqBqC,oBAAnC,EAAyD;AACvDC,EAAAA,GAAG,EAAEF,YADkD;AAEvDG,EAAAA,IAAI,EAAEH,YAFiD;AAGvDI,EAAAA,GAAG,EAAEJ,YAHkD;AAIvDK,EAAAA,IAAI,EAAEL;AAJiD,CAAzD,CADJ;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAzC,UAAU,CAACK,SAAX,CAAqB0C,YAArB,GAAoC,UAASC,YAAT,EAAuBjB,GAAvB,EAA4B;AAC9D,MAAIkB,OAAJ;;AAEA,MAAIC,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,WAAO,KAAKC,aAAL,CAAmBJ,YAAnB,CAAP;AACD;;AAEDC,EAAAA,OAAO,GAAG,KAAKP,oBAAL,CAA0BM,YAA1B,CAAV;;AAEA,MAAI,CAACC,OAAL,EAAc;AACZ,UAAM,IAAII,KAAJ,CAAU,gBAAgBL,YAAhB,GAA+B,aAAzC,CAAN;AACD;;AAED,SAAOC,OAAO,CAAC9C,IAAR,CAAa,IAAb,EAAmB4B,GAAnB,CAAP;AACD,CAdD;AAgBA;AACA;AACA;;;AAEAuB,MAAM,CAACC,OAAP,GAAiBvD,UAAjB","sourcesContent":["/*!\n * Module requirements.\n */\n\nvar MongooseError = require('../error');\nvar utils = require('../utils');\n\nvar SchemaType = require('../schematype');\n\nvar CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     var schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function(when) {\n  if (!this._index || this._index.constructor.name !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function(value) {\n  return value instanceof Date;\n};\n\n/**\n * Sets a minimum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     var schema = new Schema({ d: { type: Date, min: min })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaDate.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    var msg = message || MongooseError.messages.Date.min;\n    msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));\n    var _this = this;\n    this.validators.push({\n      validator: this.minValidator = function(val) {\n        var min = (value === Date.now ? value() : _this.cast(value));\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     var schema = new Schema({ d: { type: Date, max: max })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaDate.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    var msg = message || MongooseError.messages.Date.max;\n    msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));\n    var _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function(val) {\n        var max = (value === Date.now ? value() : _this.cast(value));\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function(value) {\n  // If null or undefined\n  if (value === null || value === void 0 || value === '') {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    if (isNaN(value.valueOf())) {\n      throw new CastError('date', value, this.path);\n    }\n\n    return value;\n  }\n\n  var date;\n\n  if (typeof value === 'boolean') {\n    throw new CastError('date', value, this.path);\n  }\n\n  if (value instanceof Number || typeof value === 'number'\n      || String(value) == Number(value)) {\n    // support for timestamps\n    date = new Date(Number(value));\n  } else if (value.valueOf) {\n    // support for moment.js\n    date = new Date(value.valueOf());\n  }\n\n  if (!isNaN(date.valueOf())) {\n    return date;\n  }\n\n  throw new CastError('date', value, this.path);\n};\n\n/*!\n * Date Query casting.\n *\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDate.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function($conditional, val) {\n  var handler;\n\n  if (arguments.length !== 2) {\n    return this._castForQuery($conditional);\n  }\n\n  handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;\n"]},"metadata":{},"sourceType":"script"}