{"ast":null,"code":"/* eslint no-empty: 1 */\n\n/*!\n * Module dependencies.\n */\nvar ArrayType = require('./array');\n\nvar CastError = require('../error/cast');\n\nvar Document = require('../document');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar SchemaType = require('../schematype');\n\nvar discriminator = require('../services/model/discriminator');\n\nvar util = require('util');\n\nvar utils = require('../utils');\n\nvar MongooseDocumentArray;\nvar Subdocument;\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArray(key, schema, options) {\n  var EmbeddedDocument = _createConstructor(schema, options);\n\n  EmbeddedDocument.prototype.$basePath = key;\n  ArrayType.call(this, key, EmbeddedDocument, options);\n  this.schema = schema;\n  this.$isMongooseDocumentArray = true;\n  var fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function () {\n      var arr = fn.call(this);\n\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      } // Leave it up to `cast()` to convert this to a documentarray\n\n\n      return arr;\n    });\n  }\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nDocumentArray.schemaName = 'DocumentArray';\n/*!\n * Inherits from ArrayType.\n */\n\nDocumentArray.prototype = Object.create(ArrayType.prototype);\nDocumentArray.prototype.constructor = DocumentArray;\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options) {\n  Subdocument || (Subdocument = require('../types/embedded')); // compile an embedded document for this schema\n\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n  }\n\n  EmbeddedDocument.prototype = Object.create(Subdocument.prototype);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true; // apply methods\n\n  for (var i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  } // apply statics\n\n\n  for (i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n  return EmbeddedDocument;\n}\n/*!\n * Ignore\n */\n\n\nDocumentArray.prototype.discriminator = function (name, schema) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema);\n\n  var EmbeddedDocument = _createConstructor(schema);\n\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {// Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n  return this.casterConstructor.discriminators[name];\n};\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\n\nDocumentArray.prototype.doValidate = function (array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  var _this = this;\n\n  SchemaType.prototype.doValidate.call(this, array, function (err) {\n    if (err) {\n      return fn(err);\n    }\n\n    var count = array && array.length;\n    var error;\n\n    if (!count) {\n      return fn();\n    }\n\n    if (options && options.updateValidator) {\n      return fn();\n    }\n\n    if (!array.isMongooseDocumentArray) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    } // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n\n    function callback(err) {\n      if (err) {\n        error = err;\n      }\n\n      --count || fn(error);\n    }\n\n    for (var i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      var doc = array[i];\n\n      if (!doc) {\n        --count || fn(error);\n        continue;\n      } // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n\n\n      if (!(doc instanceof Subdocument)) {\n        doc = array[i] = new _this.casterConstructor(doc, array, undefined, undefined, i);\n      } // HACK: use $__original_validate to avoid promises so bluebird doesn't\n      // complain\n\n\n      if (doc.$__original_validate) {\n        doc.$__original_validate({\n          __noPromise: true\n        }, callback);\n      } else {\n        doc.validate({\n          __noPromise: true\n        }, callback);\n      }\n    }\n  }, scope);\n};\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\n\nDocumentArray.prototype.doValidateSync = function (array, scope) {\n  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n\n  if (schemaTypeError) {\n    return schemaTypeError;\n  }\n\n  var count = array && array.length,\n      resultError = null;\n\n  if (!count) {\n    return;\n  } // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n\n  for (var i = 0, len = count; i < len; ++i) {\n    // only first error\n    if (resultError) {\n      break;\n    } // sidestep sparse entries\n\n\n    var doc = array[i];\n\n    if (!doc) {\n      continue;\n    } // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n\n\n    if (!(doc instanceof Subdocument)) {\n      doc = array[i] = new this.casterConstructor(doc, array, undefined, undefined, i);\n    }\n\n    var subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\n\nDocumentArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n  var selected;\n  var subdoc;\n  var i;\n  var _opts = {\n    transform: false,\n    virtuals: false\n  };\n\n  if (!Array.isArray(value)) {\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n\n    return this.cast([value], doc, init, prev);\n  }\n\n  if (!(value && value.isMongooseDocumentArray) && (!options || !options.skipDocumentArrayCast)) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n\n    if (prev && prev._handlers) {\n      for (var key in prev._handlers) {\n        doc.removeListener(key, prev._handlers[key]);\n      }\n    }\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  i = value.length;\n\n  while (i--) {\n    if (!value[i]) {\n      continue;\n    }\n\n    var Constructor = this.casterConstructor;\n\n    if (Constructor.discriminators && typeof value[i][Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]];\n    } // Check if the document has a different schema (re gh-3701)\n\n\n    if (value[i] instanceof Document && value[i].schema !== Constructor.schema) {\n      value[i] = value[i].toObject({\n        transform: false,\n        virtuals: false\n      });\n    }\n\n    if (!(value[i] instanceof Subdocument) && value[i]) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, true, selected, i);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        if (prev && (subdoc = prev.id(value[i]._id))) {\n          subdoc = prev.id(value[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(value[i]); // if set() is hooked it will have no return value\n          // see gh-746\n\n          value[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(value[i], value, undefined, undefined, i); // if set() is hooked it will have no return value\n            // see gh-746\n\n            value[i] = subdoc;\n          } catch (error) {\n            var valueInErrorMessage = util.inspect(value[i]);\n            throw new CastError('embedded', valueInErrorMessage, value._path, error);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArray} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  var path = array.path + '.';\n  var keys = Object.keys(fields);\n  var i = keys.length;\n  var selected = {};\n  var hasKeys;\n  var key;\n  var sub;\n\n  while (i--) {\n    key = keys[i];\n\n    if (key.indexOf(path) === 0) {\n      sub = key.substring(path.length);\n\n      if (sub === '$') {\n        continue;\n      }\n\n      if (sub.indexOf('$.') === 0) {\n        sub = sub.substr(2);\n      }\n\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n/*!\n * Module exports.\n */\n\n\nmodule.exports = DocumentArray;","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/mongoose/lib/schema/documentarray.js"],"names":["ArrayType","require","CastError","Document","EventEmitter","SchemaType","discriminator","util","utils","MongooseDocumentArray","Subdocument","DocumentArray","key","schema","options","EmbeddedDocument","_createConstructor","prototype","$basePath","call","$isMongooseDocumentArray","fn","defaultValue","default","arr","Array","isArray","schemaName","Object","create","constructor","apply","arguments","$__setSchema","$isArraySubdocument","i","methods","statics","name","getFunctionName","casterConstructor","baseCasterConstructor","defineProperty","value","error","discriminators","doValidate","array","scope","_this","err","count","length","updateValidator","isMongooseDocumentArray","path","callback","len","doc","undefined","$__original_validate","__noPromise","validate","doValidateSync","schemaTypeError","resultError","subdocValidateError","validateSync","cast","init","prev","selected","subdoc","_opts","transform","virtuals","markModified","skipDocumentArrayCast","_handlers","removeListener","Constructor","discriminatorKey","toObject","scopePaths","$__","id","_id","deepEqual","set","valueInErrorMessage","inspect","_path","fields","keys","hasKeys","sub","indexOf","substring","substr","module","exports"],"mappings":"AAAA;;AAEA;AACA;AACA;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,eAAD,CAAvB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,aAAD,CAAtB;;AACA,IAAIG,YAAY,GAAGH,OAAO,CAAC,QAAD,CAAP,CAAkBG,YAArC;;AACA,IAAIC,UAAU,GAAGJ,OAAO,CAAC,eAAD,CAAxB;;AACA,IAAIK,aAAa,GAAGL,OAAO,CAAC,iCAAD,CAA3B;;AACA,IAAIM,IAAI,GAAGN,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIO,KAAK,GAAGP,OAAO,CAAC,UAAD,CAAnB;;AAEA,IAAIQ,qBAAJ;AACA,IAAIC,WAAJ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,aAAT,CAAuBC,GAAvB,EAA4BC,MAA5B,EAAoCC,OAApC,EAA6C;AAC3C,MAAIC,gBAAgB,GAAGC,kBAAkB,CAACH,MAAD,EAASC,OAAT,CAAzC;;AACAC,EAAAA,gBAAgB,CAACE,SAAjB,CAA2BC,SAA3B,GAAuCN,GAAvC;AAEAZ,EAAAA,SAAS,CAACmB,IAAV,CAAe,IAAf,EAAqBP,GAArB,EAA0BG,gBAA1B,EAA4CD,OAA5C;AAEA,OAAKD,MAAL,GAAcA,MAAd;AACA,OAAKO,wBAAL,GAAgC,IAAhC;AACA,MAAIC,EAAE,GAAG,KAAKC,YAAd;;AAEA,MAAI,EAAE,kBAAkB,IAApB,KAA6BD,EAAE,KAAK,KAAK,CAA7C,EAAgD;AAC9C,SAAKE,OAAL,CAAa,YAAW;AACtB,UAAIC,GAAG,GAAGH,EAAE,CAACF,IAAH,CAAQ,IAAR,CAAV;;AACA,UAAI,CAACM,KAAK,CAACC,OAAN,CAAcF,GAAd,CAAL,EAAyB;AACvBA,QAAAA,GAAG,GAAG,CAACA,GAAD,CAAN;AACD,OAJqB,CAKtB;;;AACA,aAAOA,GAAP;AACD,KAPD;AAQD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;;;AACAb,aAAa,CAACgB,UAAd,GAA2B,eAA3B;AAEA;AACA;AACA;;AACAhB,aAAa,CAACM,SAAd,GAA0BW,MAAM,CAACC,MAAP,CAAc7B,SAAS,CAACiB,SAAxB,CAA1B;AACAN,aAAa,CAACM,SAAd,CAAwBa,WAAxB,GAAsCnB,aAAtC;AAEA;AACA;AACA;;AAEA,SAASK,kBAAT,CAA4BH,MAA5B,EAAoCC,OAApC,EAA6C;AAC3CJ,EAAAA,WAAW,KAAKA,WAAW,GAAGT,OAAO,CAAC,mBAAD,CAA1B,CAAX,CAD2C,CAG3C;;AACA,WAASc,gBAAT,GAA4B;AAC1BL,IAAAA,WAAW,CAACqB,KAAZ,CAAkB,IAAlB,EAAwBC,SAAxB;AACD;;AAEDjB,EAAAA,gBAAgB,CAACE,SAAjB,GAA6BW,MAAM,CAACC,MAAP,CAAcnB,WAAW,CAACO,SAA1B,CAA7B;AACAF,EAAAA,gBAAgB,CAACE,SAAjB,CAA2BgB,YAA3B,CAAwCpB,MAAxC;AACAE,EAAAA,gBAAgB,CAACF,MAAjB,GAA0BA,MAA1B;AACAE,EAAAA,gBAAgB,CAACE,SAAjB,CAA2Ba,WAA3B,GAAyCf,gBAAzC;AACAA,EAAAA,gBAAgB,CAACmB,mBAAjB,GAAuC,IAAvC,CAZ2C,CAc3C;;AACA,OAAK,IAAIC,CAAT,IAActB,MAAM,CAACuB,OAArB,EAA8B;AAC5BrB,IAAAA,gBAAgB,CAACE,SAAjB,CAA2BkB,CAA3B,IAAgCtB,MAAM,CAACuB,OAAP,CAAeD,CAAf,CAAhC;AACD,GAjB0C,CAmB3C;;;AACA,OAAKA,CAAL,IAAUtB,MAAM,CAACwB,OAAjB,EAA0B;AACxBtB,IAAAA,gBAAgB,CAACoB,CAAD,CAAhB,GAAsBtB,MAAM,CAACwB,OAAP,CAAeF,CAAf,CAAtB;AACD;;AAED,OAAKA,CAAL,IAAU/B,YAAY,CAACa,SAAvB,EAAkC;AAChCF,IAAAA,gBAAgB,CAACoB,CAAD,CAAhB,GAAsB/B,YAAY,CAACa,SAAb,CAAuBkB,CAAvB,CAAtB;AACD;;AAEDpB,EAAAA,gBAAgB,CAACD,OAAjB,GAA2BA,OAA3B;AAEA,SAAOC,gBAAP;AACD;AAED;AACA;AACA;;;AAEAJ,aAAa,CAACM,SAAd,CAAwBX,aAAxB,GAAwC,UAASgC,IAAT,EAAezB,MAAf,EAAuB;AAC7D,MAAI,OAAOyB,IAAP,KAAgB,UAApB,EAAgC;AAC9BA,IAAAA,IAAI,GAAG9B,KAAK,CAAC+B,eAAN,CAAsBD,IAAtB,CAAP;AACD;;AAEDzB,EAAAA,MAAM,GAAGP,aAAa,CAAC,KAAKkC,iBAAN,EAAyBF,IAAzB,EAA+BzB,MAA/B,CAAtB;;AAEA,MAAIE,gBAAgB,GAAGC,kBAAkB,CAACH,MAAD,CAAzC;;AACAE,EAAAA,gBAAgB,CAAC0B,qBAAjB,GAAyC,KAAKD,iBAA9C;;AAEA,MAAI;AACFZ,IAAAA,MAAM,CAACc,cAAP,CAAsB3B,gBAAtB,EAAwC,MAAxC,EAAgD;AAC9C4B,MAAAA,KAAK,EAAEL;AADuC,KAAhD;AAGD,GAJD,CAIE,OAAOM,KAAP,EAAc,CACd;AACD;;AAED,OAAKJ,iBAAL,CAAuBK,cAAvB,CAAsCP,IAAtC,IAA8CvB,gBAA9C;AAEA,SAAO,KAAKyB,iBAAL,CAAuBK,cAAvB,CAAsCP,IAAtC,CAAP;AACD,CArBD;AAuBA;AACA;AACA;AACA;AACA;;;AAEA3B,aAAa,CAACM,SAAd,CAAwB6B,UAAxB,GAAqC,UAASC,KAAT,EAAgB1B,EAAhB,EAAoB2B,KAApB,EAA2BlC,OAA3B,EAAoC;AACvE;AACAL,EAAAA,qBAAqB,KAAKA,qBAAqB,GAAGR,OAAO,CAAC,wBAAD,CAApC,CAArB;;AAEA,MAAIgD,KAAK,GAAG,IAAZ;;AACA5C,EAAAA,UAAU,CAACY,SAAX,CAAqB6B,UAArB,CAAgC3B,IAAhC,CAAqC,IAArC,EAA2C4B,KAA3C,EAAkD,UAASG,GAAT,EAAc;AAC9D,QAAIA,GAAJ,EAAS;AACP,aAAO7B,EAAE,CAAC6B,GAAD,CAAT;AACD;;AAED,QAAIC,KAAK,GAAGJ,KAAK,IAAIA,KAAK,CAACK,MAA3B;AACA,QAAIR,KAAJ;;AAEA,QAAI,CAACO,KAAL,EAAY;AACV,aAAO9B,EAAE,EAAT;AACD;;AACD,QAAIP,OAAO,IAAIA,OAAO,CAACuC,eAAvB,EAAwC;AACtC,aAAOhC,EAAE,EAAT;AACD;;AACD,QAAI,CAAC0B,KAAK,CAACO,uBAAX,EAAoC;AAClCP,MAAAA,KAAK,GAAG,IAAItC,qBAAJ,CAA0BsC,KAA1B,EAAiCE,KAAK,CAACM,IAAvC,EAA6CP,KAA7C,CAAR;AACD,KAhB6D,CAkB9D;AACA;AACA;;;AAEA,aAASQ,QAAT,CAAkBN,GAAlB,EAAuB;AACrB,UAAIA,GAAJ,EAAS;AACPN,QAAAA,KAAK,GAAGM,GAAR;AACD;;AACD,QAAEC,KAAF,IAAW9B,EAAE,CAACuB,KAAD,CAAb;AACD;;AAED,SAAK,IAAIT,CAAC,GAAG,CAAR,EAAWsB,GAAG,GAAGN,KAAtB,EAA6BhB,CAAC,GAAGsB,GAAjC,EAAsC,EAAEtB,CAAxC,EAA2C;AACzC;AACA,UAAIuB,GAAG,GAAGX,KAAK,CAACZ,CAAD,CAAf;;AACA,UAAI,CAACuB,GAAL,EAAU;AACR,UAAEP,KAAF,IAAW9B,EAAE,CAACuB,KAAD,CAAb;AACA;AACD,OANwC,CAQzC;AACA;;;AACA,UAAI,EAAEc,GAAG,YAAYhD,WAAjB,CAAJ,EAAmC;AACjCgD,QAAAA,GAAG,GAAGX,KAAK,CAACZ,CAAD,CAAL,GAAW,IAAIc,KAAK,CAACT,iBAAV,CAA4BkB,GAA5B,EAAiCX,KAAjC,EAAwCY,SAAxC,EACbA,SADa,EACFxB,CADE,CAAjB;AAED,OAbwC,CAezC;AACA;;;AACA,UAAIuB,GAAG,CAACE,oBAAR,EAA8B;AAC5BF,QAAAA,GAAG,CAACE,oBAAJ,CAAyB;AAACC,UAAAA,WAAW,EAAE;AAAd,SAAzB,EAA8CL,QAA9C;AACD,OAFD,MAEO;AACLE,QAAAA,GAAG,CAACI,QAAJ,CAAa;AAACD,UAAAA,WAAW,EAAE;AAAd,SAAb,EAAkCL,QAAlC;AACD;AACF;AACF,GApDD,EAoDGR,KApDH;AAqDD,CA1DD;AA4DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEArC,aAAa,CAACM,SAAd,CAAwB8C,cAAxB,GAAyC,UAAShB,KAAT,EAAgBC,KAAhB,EAAuB;AAC9D,MAAIgB,eAAe,GAAG3D,UAAU,CAACY,SAAX,CAAqB8C,cAArB,CAAoC5C,IAApC,CAAyC,IAAzC,EAA+C4B,KAA/C,EAAsDC,KAAtD,CAAtB;;AACA,MAAIgB,eAAJ,EAAqB;AACnB,WAAOA,eAAP;AACD;;AAED,MAAIb,KAAK,GAAGJ,KAAK,IAAIA,KAAK,CAACK,MAA3B;AAAA,MACIa,WAAW,GAAG,IADlB;;AAGA,MAAI,CAACd,KAAL,EAAY;AACV;AACD,GAX6D,CAa9D;AACA;AACA;;;AAEA,OAAK,IAAIhB,CAAC,GAAG,CAAR,EAAWsB,GAAG,GAAGN,KAAtB,EAA6BhB,CAAC,GAAGsB,GAAjC,EAAsC,EAAEtB,CAAxC,EAA2C;AACzC;AACA,QAAI8B,WAAJ,EAAiB;AACf;AACD,KAJwC,CAKzC;;;AACA,QAAIP,GAAG,GAAGX,KAAK,CAACZ,CAAD,CAAf;;AACA,QAAI,CAACuB,GAAL,EAAU;AACR;AACD,KATwC,CAWzC;AACA;;;AACA,QAAI,EAAEA,GAAG,YAAYhD,WAAjB,CAAJ,EAAmC;AACjCgD,MAAAA,GAAG,GAAGX,KAAK,CAACZ,CAAD,CAAL,GAAW,IAAI,KAAKK,iBAAT,CAA2BkB,GAA3B,EAAgCX,KAAhC,EAAuCY,SAAvC,EACfA,SADe,EACJxB,CADI,CAAjB;AAED;;AAED,QAAI+B,mBAAmB,GAAGR,GAAG,CAACS,YAAJ,EAA1B;;AAEA,QAAID,mBAAJ,EAAyB;AACvBD,MAAAA,WAAW,GAAGC,mBAAd;AACD;AACF;;AAED,SAAOD,WAAP;AACD,CA3CD;AA6CA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAtD,aAAa,CAACM,SAAd,CAAwBmD,IAAxB,GAA+B,UAASzB,KAAT,EAAgBe,GAAhB,EAAqBW,IAArB,EAA2BC,IAA3B,EAAiCxD,OAAjC,EAA0C;AACvE;AACAL,EAAAA,qBAAqB,KAAKA,qBAAqB,GAAGR,OAAO,CAAC,wBAAD,CAApC,CAArB;AAEA,MAAIsE,QAAJ;AACA,MAAIC,MAAJ;AACA,MAAIrC,CAAJ;AACA,MAAIsC,KAAK,GAAG;AAAEC,IAAAA,SAAS,EAAE,KAAb;AAAoBC,IAAAA,QAAQ,EAAE;AAA9B,GAAZ;;AAEA,MAAI,CAAClD,KAAK,CAACC,OAAN,CAAciB,KAAd,CAAL,EAA2B;AACzB;AACA;AACA,QAAI,CAAC,CAACe,GAAF,IAASW,IAAb,EAAmB;AACjBX,MAAAA,GAAG,CAACkB,YAAJ,CAAiB,KAAKrB,IAAtB;AACD;;AACD,WAAO,KAAKa,IAAL,CAAU,CAACzB,KAAD,CAAV,EAAmBe,GAAnB,EAAwBW,IAAxB,EAA8BC,IAA9B,CAAP;AACD;;AAED,MAAI,EAAE3B,KAAK,IAAIA,KAAK,CAACW,uBAAjB,MACC,CAACxC,OAAD,IAAY,CAACA,OAAO,CAAC+D,qBADtB,CAAJ,EACkD;AAChDlC,IAAAA,KAAK,GAAG,IAAIlC,qBAAJ,CAA0BkC,KAA1B,EAAiC,KAAKY,IAAtC,EAA4CG,GAA5C,CAAR;;AACA,QAAIY,IAAI,IAAIA,IAAI,CAACQ,SAAjB,EAA4B;AAC1B,WAAK,IAAIlE,GAAT,IAAgB0D,IAAI,CAACQ,SAArB,EAAgC;AAC9BpB,QAAAA,GAAG,CAACqB,cAAJ,CAAmBnE,GAAnB,EAAwB0D,IAAI,CAACQ,SAAL,CAAelE,GAAf,CAAxB;AACD;AACF;AACF,GARD,MAQO,IAAI+B,KAAK,IAAIA,KAAK,CAACW,uBAAnB,EAA4C;AACjD;AACA;AACAX,IAAAA,KAAK,GAAG,IAAIlC,qBAAJ,CAA0BkC,KAA1B,EAAiC,KAAKY,IAAtC,EAA4CG,GAA5C,CAAR;AACD;;AAEDvB,EAAAA,CAAC,GAAGQ,KAAK,CAACS,MAAV;;AAEA,SAAOjB,CAAC,EAAR,EAAY;AACV,QAAI,CAACQ,KAAK,CAACR,CAAD,CAAV,EAAe;AACb;AACD;;AAED,QAAI6C,WAAW,GAAG,KAAKxC,iBAAvB;;AACA,QAAIwC,WAAW,CAACnC,cAAZ,IACA,OAAOF,KAAK,CAACR,CAAD,CAAL,CAAS6C,WAAW,CAACnE,MAAZ,CAAmBC,OAAnB,CAA2BmE,gBAApC,CAAP,KAAiE,QADjE,IAEAD,WAAW,CAACnC,cAAZ,CAA2BF,KAAK,CAACR,CAAD,CAAL,CAAS6C,WAAW,CAACnE,MAAZ,CAAmBC,OAAnB,CAA2BmE,gBAApC,CAA3B,CAFJ,EAEuF;AACrFD,MAAAA,WAAW,GAAGA,WAAW,CAACnC,cAAZ,CAA2BF,KAAK,CAACR,CAAD,CAAL,CAAS6C,WAAW,CAACnE,MAAZ,CAAmBC,OAAnB,CAA2BmE,gBAApC,CAA3B,CAAd;AACD,KAVS,CAYV;;;AACA,QAAKtC,KAAK,CAACR,CAAD,CAAL,YAAoBhC,QAArB,IACAwC,KAAK,CAACR,CAAD,CAAL,CAAStB,MAAT,KAAoBmE,WAAW,CAACnE,MADpC,EAC4C;AAC1C8B,MAAAA,KAAK,CAACR,CAAD,CAAL,GAAWQ,KAAK,CAACR,CAAD,CAAL,CAAS+C,QAAT,CAAkB;AAAER,QAAAA,SAAS,EAAE,KAAb;AAAoBC,QAAAA,QAAQ,EAAE;AAA9B,OAAlB,CAAX;AACD;;AACD,QAAI,EAAEhC,KAAK,CAACR,CAAD,CAAL,YAAoBzB,WAAtB,KAAsCiC,KAAK,CAACR,CAAD,CAA/C,EAAoD;AAClD,UAAIkC,IAAJ,EAAU;AACR,YAAIX,GAAJ,EAAS;AACPa,UAAAA,QAAQ,KAAKA,QAAQ,GAAGY,UAAU,CAAC,IAAD,EAAOzB,GAAG,CAAC0B,GAAJ,CAAQb,QAAf,EAAyBF,IAAzB,CAA1B,CAAR;AACD,SAFD,MAEO;AACLE,UAAAA,QAAQ,GAAG,IAAX;AACD;;AAEDC,QAAAA,MAAM,GAAG,IAAIQ,WAAJ,CAAgB,IAAhB,EAAsBrC,KAAtB,EAA6B,IAA7B,EAAmC4B,QAAnC,EAA6CpC,CAA7C,CAAT;AACAQ,QAAAA,KAAK,CAACR,CAAD,CAAL,GAAWqC,MAAM,CAACH,IAAP,CAAY1B,KAAK,CAACR,CAAD,CAAjB,CAAX;AACD,OATD,MASO;AACL,YAAImC,IAAI,KAAKE,MAAM,GAAGF,IAAI,CAACe,EAAL,CAAQ1C,KAAK,CAACR,CAAD,CAAL,CAASmD,GAAjB,CAAd,CAAR,EAA8C;AAC5Cd,UAAAA,MAAM,GAAGF,IAAI,CAACe,EAAL,CAAQ1C,KAAK,CAACR,CAAD,CAAL,CAASmD,GAAjB,CAAT;AACD;;AAED,YAAIhB,IAAI,IAAIE,MAAR,IAAkBhE,KAAK,CAAC+E,SAAN,CAAgBf,MAAM,CAACU,QAAP,CAAgBT,KAAhB,CAAhB,EAAwC9B,KAAK,CAACR,CAAD,CAA7C,CAAtB,EAAyE;AACvE;AACAqC,UAAAA,MAAM,CAACgB,GAAP,CAAW7C,KAAK,CAACR,CAAD,CAAhB,EAFuE,CAGvE;AACA;;AACAQ,UAAAA,KAAK,CAACR,CAAD,CAAL,GAAWqC,MAAX;AACD,SAND,MAMO;AACL,cAAI;AACFA,YAAAA,MAAM,GAAG,IAAIQ,WAAJ,CAAgBrC,KAAK,CAACR,CAAD,CAArB,EAA0BQ,KAA1B,EAAiCgB,SAAjC,EACLA,SADK,EACMxB,CADN,CAAT,CADE,CAGF;AACA;;AACAQ,YAAAA,KAAK,CAACR,CAAD,CAAL,GAAWqC,MAAX;AACD,WAND,CAME,OAAO5B,KAAP,EAAc;AACd,gBAAI6C,mBAAmB,GAAGlF,IAAI,CAACmF,OAAL,CAAa/C,KAAK,CAACR,CAAD,CAAlB,CAA1B;AACA,kBAAM,IAAIjC,SAAJ,CAAc,UAAd,EAA0BuF,mBAA1B,EACJ9C,KAAK,CAACgD,KADF,EACS/C,KADT,CAAN;AAED;AACF;AACF;AACF;AACF;;AAED,SAAOD,KAAP;AACD,CA1FD;AA4FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASwC,UAAT,CAAoBpC,KAApB,EAA2B6C,MAA3B,EAAmCvB,IAAnC,EAAyC;AACvC,MAAI,EAAEA,IAAI,IAAIuB,MAAV,CAAJ,EAAuB;AACrB,WAAOjC,SAAP;AACD;;AAED,MAAIJ,IAAI,GAAGR,KAAK,CAACQ,IAAN,GAAa,GAAxB;AACA,MAAIsC,IAAI,GAAGjE,MAAM,CAACiE,IAAP,CAAYD,MAAZ,CAAX;AACA,MAAIzD,CAAC,GAAG0D,IAAI,CAACzC,MAAb;AACA,MAAImB,QAAQ,GAAG,EAAf;AACA,MAAIuB,OAAJ;AACA,MAAIlF,GAAJ;AACA,MAAImF,GAAJ;;AAEA,SAAO5D,CAAC,EAAR,EAAY;AACVvB,IAAAA,GAAG,GAAGiF,IAAI,CAAC1D,CAAD,CAAV;;AACA,QAAIvB,GAAG,CAACoF,OAAJ,CAAYzC,IAAZ,MAAsB,CAA1B,EAA6B;AAC3BwC,MAAAA,GAAG,GAAGnF,GAAG,CAACqF,SAAJ,CAAc1C,IAAI,CAACH,MAAnB,CAAN;;AACA,UAAI2C,GAAG,KAAK,GAAZ,EAAiB;AACf;AACD;;AACD,UAAIA,GAAG,CAACC,OAAJ,CAAY,IAAZ,MAAsB,CAA1B,EAA6B;AAC3BD,QAAAA,GAAG,GAAGA,GAAG,CAACG,MAAJ,CAAW,CAAX,CAAN;AACD;;AACDJ,MAAAA,OAAO,KAAKA,OAAO,GAAG,IAAf,CAAP;AACAvB,MAAAA,QAAQ,CAACwB,GAAD,CAAR,GAAgBH,MAAM,CAAChF,GAAD,CAAtB;AACD;AACF;;AAED,SAAOkF,OAAO,IAAIvB,QAAX,IAAuBZ,SAA9B;AACD;AAED;AACA;AACA;;;AAEAwC,MAAM,CAACC,OAAP,GAAiBzF,aAAjB","sourcesContent":["/* eslint no-empty: 1 */\n\n/*!\n * Module dependencies.\n */\n\nvar ArrayType = require('./array');\nvar CastError = require('../error/cast');\nvar Document = require('../document');\nvar EventEmitter = require('events').EventEmitter;\nvar SchemaType = require('../schematype');\nvar discriminator = require('../services/model/discriminator');\nvar util = require('util');\nvar utils = require('../utils');\n\nvar MongooseDocumentArray;\nvar Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArray(key, schema, options) {\n  var EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.$isMongooseDocumentArray = true;\n  var fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      var arr = fn.call(this);\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDocumentArray.schemaName = 'DocumentArray';\n\n/*!\n * Inherits from ArrayType.\n */\nDocumentArray.prototype = Object.create(ArrayType.prototype);\nDocumentArray.prototype.constructor = DocumentArray;\n\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options) {\n  Subdocument || (Subdocument = require('../types/embedded'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n  }\n\n  EmbeddedDocument.prototype = Object.create(Subdocument.prototype);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n\n  // apply methods\n  for (var i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/*!\n * Ignore\n */\n\nDocumentArray.prototype.discriminator = function(name, schema) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema);\n\n  var EmbeddedDocument = _createConstructor(schema);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nDocumentArray.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  var _this = this;\n  SchemaType.prototype.doValidate.call(this, array, function(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    var count = array && array.length;\n    var error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!array.isMongooseDocumentArray) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n\n    for (var i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      var doc = array[i];\n      if (!doc) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        doc = array[i] = new _this.casterConstructor(doc, array, undefined,\n            undefined, i);\n      }\n\n      // HACK: use $__original_validate to avoid promises so bluebird doesn't\n      // complain\n      if (doc.$__original_validate) {\n        doc.$__original_validate({__noPromise: true}, callback);\n      } else {\n        doc.validate({__noPromise: true}, callback);\n      }\n    }\n  }, scope);\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nDocumentArray.prototype.doValidateSync = function(array, scope) {\n  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError) {\n    return schemaTypeError;\n  }\n\n  var count = array && array.length,\n      resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (var i = 0, len = count; i < len; ++i) {\n    // only first error\n    if (resultError) {\n      break;\n    }\n    // sidestep sparse entries\n    var doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      doc = array[i] = new this.casterConstructor(doc, array, undefined,\n        undefined, i);\n    }\n\n    var subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nDocumentArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  var selected;\n  var subdoc;\n  var i;\n  var _opts = { transform: false, virtuals: false };\n\n  if (!Array.isArray(value)) {\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init, prev);\n  }\n\n  if (!(value && value.isMongooseDocumentArray) &&\n      (!options || !options.skipDocumentArrayCast)) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n    if (prev && prev._handlers) {\n      for (var key in prev._handlers) {\n        doc.removeListener(key, prev._handlers[key]);\n      }\n    }\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  i = value.length;\n\n  while (i--) {\n    if (!value[i]) {\n      continue;\n    }\n\n    var Constructor = this.casterConstructor;\n    if (Constructor.discriminators &&\n        typeof value[i][Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]];\n    }\n\n    // Check if the document has a different schema (re gh-3701)\n    if ((value[i] instanceof Document) &&\n        value[i].schema !== Constructor.schema) {\n      value[i] = value[i].toObject({ transform: false, virtuals: false });\n    }\n    if (!(value[i] instanceof Subdocument) && value[i]) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, true, selected, i);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        if (prev && (subdoc = prev.id(value[i]._id))) {\n          subdoc = prev.id(value[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(value[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          value[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(value[i], value, undefined,\n                undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            value[i] = subdoc;\n          } catch (error) {\n            var valueInErrorMessage = util.inspect(value[i]);\n            throw new CastError('embedded', valueInErrorMessage,\n              value._path, error);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArray} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  var path = array.path + '.';\n  var keys = Object.keys(fields);\n  var i = keys.length;\n  var selected = {};\n  var hasKeys;\n  var key;\n  var sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.indexOf(path) === 0) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.indexOf('$.') === 0) {\n        sub = sub.substr(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArray;\n"]},"metadata":{},"sourceType":"script"}