{"ast":null,"code":"/*!\n * Module dependencies.\n */\nvar NodeJSDocument = require('./document');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar MongooseError = require('./error');\n\nvar Schema = require('./schema');\n\nvar ObjectId = require('./types/objectid');\n\nvar utils = require('./utils');\n\nvar ValidationError = MongooseError.ValidationError;\n\nvar InternalCache = require('./internal');\n\nvar PromiseProvider = require('./promise_provider');\n\nvar VersionError = require('./error').VersionError;\n\nvar Embedded;\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, schema, fields, skipId, skipInit) {\n  if (!(this instanceof Document)) {\n    return new Document(obj, schema, fields, skipId, skipInit);\n  }\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  } // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id\n\n\n  schema = this.schema || schema; // Generate ObjectId if it is missing, but it requires a scheme\n\n  if (!this.schema && schema.options._id) {\n    obj = obj || {};\n\n    if (obj._id === undefined) {\n      obj._id = new ObjectId();\n    }\n  }\n\n  if (!schema) {\n    throw new MongooseError.MissingSchemaError();\n  }\n\n  this.$__setSchema(schema);\n  this.$__ = new InternalCache();\n  this.$__.emitter = new EventEmitter();\n  this.isNew = true;\n  this.errors = undefined;\n\n  if (typeof fields === 'boolean') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = this.schema.options && this.schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  var required = this.schema.requiredPaths();\n\n  for (var i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require(required[i]);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n  this._doc = this.$__buildDoc(obj, fields, skipId);\n\n  if (!skipInit && obj) {\n    this.init(obj);\n  }\n\n  this.$__registerHooksFromSchema(); // apply methods\n\n  for (var m in schema.methods) {\n    this[m] = schema.methods[m];\n  } // apply statics\n\n\n  for (var s in schema.statics) {\n    this[s] = schema.statics[s];\n  }\n}\n/*!\n * Inherit from the NodeJS document\n */\n\n\nDocument.prototype = Object.create(NodeJSDocument.prototype);\nDocument.prototype.constructor = Document;\n/*!\n * Browser doc exposes the event emitter API\n */\n\nDocument.$emitter = new EventEmitter();\nutils.each(['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners', 'removeAllListeners', 'addListener'], function (emitterFn) {\n  Document[emitterFn] = function () {\n    return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);\n  };\n});\n/*!\n * Executes methods queued from the Schema definition\n *\n * @api private\n * @method $__registerHooksFromSchema\n * @deprecated\n * @memberOf Document\n */\n\nDocument.prototype.$__registerHooksFromSchema = function () {\n  Embedded = Embedded || require('./types/embedded');\n  var Promise = PromiseProvider.get();\n\n  var _this = this;\n\n  var q = _this.schema && _this.schema.callQueue;\n  var toWrapEl;\n  var len;\n  var i;\n  var j;\n  var pointCut;\n  var keys;\n\n  if (!q.length) {\n    return _this;\n  } // we are only interested in 'pre' hooks, and group by point-cut\n\n\n  var toWrap = {\n    post: []\n  };\n  var pair;\n\n  for (i = 0; i < q.length; ++i) {\n    pair = q[i];\n\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      _this[pair[0]].apply(_this, pair[1]);\n\n      continue;\n    }\n\n    var args = [].slice.call(pair[1]);\n    pointCut = pair[0] === 'on' ? 'post' : args[0];\n\n    if (!(pointCut in toWrap)) {\n      toWrap[pointCut] = {\n        post: [],\n        pre: []\n      };\n    }\n\n    if (pair[0] === 'post') {\n      toWrap[pointCut].post.push(args);\n    } else if (pair[0] === 'on') {\n      toWrap[pointCut].push(args);\n    } else {\n      toWrap[pointCut].pre.push(args);\n    }\n  } // 'post' hooks are simpler\n\n\n  len = toWrap.post.length;\n  toWrap.post.forEach(function (args) {\n    _this.on.apply(_this, args);\n  });\n  delete toWrap.post; // 'init' should be synchronous on subdocuments\n\n  if (toWrap.init && _this instanceof Embedded) {\n    if (toWrap.init.pre) {\n      toWrap.init.pre.forEach(function (args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n\n    if (toWrap.init.post) {\n      toWrap.init.post.forEach(function (args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n\n    delete toWrap.init;\n  } else if (toWrap.set) {\n    // Set hooks also need to be sync re: gh-3479\n    if (toWrap.set.pre) {\n      toWrap.set.pre.forEach(function (args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n\n    if (toWrap.set.post) {\n      toWrap.set.post.forEach(function (args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n\n    delete toWrap.set;\n  }\n\n  keys = Object.keys(toWrap);\n  len = keys.length;\n\n  for (i = 0; i < len; ++i) {\n    pointCut = keys[i]; // this is so we can wrap everything into a promise;\n\n    var newName = '$__original_' + pointCut;\n\n    if (!_this[pointCut]) {\n      continue;\n    }\n\n    if (_this[pointCut].$isWrapped) {\n      continue;\n    }\n\n    _this[newName] = _this[pointCut];\n\n    _this[pointCut] = function (_newName) {\n      return function wrappedPointCut() {\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n\n        if (lastArg && typeof lastArg !== 'function') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function (resolve, reject) {\n          args.push(function (error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n\n              _this.$__handleReject(error);\n\n              reject(error);\n              return;\n            } // There may be multiple results and promise libs other than\n            // mpromise don't support passing multiple values to `resolve()`\n\n\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n\n        if (fn) {\n          if (_this.constructor.$wrapCallback) {\n            fn = _this.constructor.$wrapCallback(fn);\n          }\n\n          return promise.then(function () {\n            process.nextTick(function () {\n              fn.apply(null, [null].concat($results));\n            });\n          }, function (error) {\n            process.nextTick(function () {\n              fn(error);\n            });\n          });\n        }\n\n        return promise;\n      };\n    }(newName);\n\n    _this[pointCut].$isWrapped = true;\n    toWrapEl = toWrap[pointCut];\n    var _len = toWrapEl.pre.length;\n    args;\n\n    for (j = 0; j < _len; ++j) {\n      args = toWrapEl.pre[j];\n      args[0] = newName;\n\n      _this.$pre.apply(_this, args);\n    }\n\n    _len = toWrapEl.post.length;\n\n    for (j = 0; j < _len; ++j) {\n      args = toWrapEl.post[j];\n      args[0] = newName;\n\n      _this.$post.apply(_this, args);\n    }\n  }\n\n  return _this;\n};\n/*!\n * Module exports.\n */\n\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/mongoose/lib/browserDocument.js"],"names":["NodeJSDocument","require","EventEmitter","MongooseError","Schema","ObjectId","utils","ValidationError","InternalCache","PromiseProvider","VersionError","Embedded","Document","obj","schema","fields","skipId","skipInit","isObject","instanceOfSchema","options","_id","undefined","MissingSchemaError","$__setSchema","$__","emitter","isNew","errors","strictMode","strict","selected","required","requiredPaths","i","length","activePaths","setMaxListeners","_doc","$__buildDoc","init","$__registerHooksFromSchema","m","methods","s","statics","prototype","Object","create","constructor","$emitter","each","emitterFn","apply","arguments","Promise","get","_this","q","callQueue","toWrapEl","len","j","pointCut","keys","toWrap","post","pair","args","slice","call","pre","push","forEach","on","$pre","$post","set","newName","$isWrapped","_newName","wrappedPointCut","lastArg","pop","fn","originalError","Error","$results","promise","ES6","resolve","reject","error","stack","$__handleReject","Array","$wrapCallback","then","process","nextTick","concat","_len","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Module dependencies.\n */\n\nvar NodeJSDocument = require('./document');\nvar EventEmitter = require('events').EventEmitter;\nvar MongooseError = require('./error');\nvar Schema = require('./schema');\nvar ObjectId = require('./types/objectid');\nvar utils = require('./utils');\nvar ValidationError = MongooseError.ValidationError;\nvar InternalCache = require('./internal');\nvar PromiseProvider = require('./promise_provider');\nvar VersionError = require('./error').VersionError;\n\nvar Embedded;\n\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, schema, fields, skipId, skipInit) {\n  if (!(this instanceof Document)) {\n    return new Document(obj, schema, fields, skipId, skipInit);\n  }\n\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n\n  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id\n  schema = this.schema || schema;\n\n  // Generate ObjectId if it is missing, but it requires a scheme\n  if (!this.schema && schema.options._id) {\n    obj = obj || {};\n\n    if (obj._id === undefined) {\n      obj._id = new ObjectId();\n    }\n  }\n\n  if (!schema) {\n    throw new MongooseError.MissingSchemaError();\n  }\n\n  this.$__setSchema(schema);\n\n  this.$__ = new InternalCache;\n  this.$__.emitter = new EventEmitter();\n  this.isNew = true;\n  this.errors = undefined;\n\n  if (typeof fields === 'boolean') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = this.schema.options && this.schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  var required = this.schema.requiredPaths();\n  for (var i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require(required[i]);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n  this._doc = this.$__buildDoc(obj, fields, skipId);\n\n  if (!skipInit && obj) {\n    this.init(obj);\n  }\n\n  this.$__registerHooksFromSchema();\n\n  // apply methods\n  for (var m in schema.methods) {\n    this[m] = schema.methods[m];\n  }\n  // apply statics\n  for (var s in schema.statics) {\n    this[s] = schema.statics[s];\n  }\n}\n\n/*!\n * Inherit from the NodeJS document\n */\n\nDocument.prototype = Object.create(NodeJSDocument.prototype);\nDocument.prototype.constructor = Document;\n\n/*!\n * Browser doc exposes the event emitter API\n */\n\nDocument.$emitter = new EventEmitter();\n\nutils.each(\n    ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n      'removeAllListeners', 'addListener'],\n    function(emitterFn) {\n      Document[emitterFn] = function() {\n        return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);\n      };\n    });\n\n/*!\n * Executes methods queued from the Schema definition\n *\n * @api private\n * @method $__registerHooksFromSchema\n * @deprecated\n * @memberOf Document\n */\n\nDocument.prototype.$__registerHooksFromSchema = function() {\n  Embedded = Embedded || require('./types/embedded');\n  var Promise = PromiseProvider.get();\n\n  var _this = this;\n  var q = _this.schema && _this.schema.callQueue;\n  var toWrapEl;\n  var len;\n  var i;\n  var j;\n  var pointCut;\n  var keys;\n  if (!q.length) {\n    return _this;\n  }\n\n  // we are only interested in 'pre' hooks, and group by point-cut\n  var toWrap = { post: [] };\n  var pair;\n\n  for (i = 0; i < q.length; ++i) {\n    pair = q[i];\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      _this[pair[0]].apply(_this, pair[1]);\n      continue;\n    }\n    var args = [].slice.call(pair[1]);\n    pointCut = pair[0] === 'on' ? 'post' : args[0];\n    if (!(pointCut in toWrap)) {\n      toWrap[pointCut] = {post: [], pre: []};\n    }\n    if (pair[0] === 'post') {\n      toWrap[pointCut].post.push(args);\n    } else if (pair[0] === 'on') {\n      toWrap[pointCut].push(args);\n    } else {\n      toWrap[pointCut].pre.push(args);\n    }\n  }\n\n  // 'post' hooks are simpler\n  len = toWrap.post.length;\n  toWrap.post.forEach(function(args) {\n    _this.on.apply(_this, args);\n  });\n  delete toWrap.post;\n\n  // 'init' should be synchronous on subdocuments\n  if (toWrap.init && _this instanceof Embedded) {\n    if (toWrap.init.pre) {\n      toWrap.init.pre.forEach(function(args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n    if (toWrap.init.post) {\n      toWrap.init.post.forEach(function(args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n    delete toWrap.init;\n  } else if (toWrap.set) {\n    // Set hooks also need to be sync re: gh-3479\n    if (toWrap.set.pre) {\n      toWrap.set.pre.forEach(function(args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n    if (toWrap.set.post) {\n      toWrap.set.post.forEach(function(args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n    delete toWrap.set;\n  }\n\n  keys = Object.keys(toWrap);\n  len = keys.length;\n  for (i = 0; i < len; ++i) {\n    pointCut = keys[i];\n    // this is so we can wrap everything into a promise;\n    var newName = ('$__original_' + pointCut);\n    if (!_this[pointCut]) {\n      continue;\n    }\n    if (_this[pointCut].$isWrapped) {\n      continue;\n    }\n    _this[newName] = _this[pointCut];\n    _this[pointCut] = (function(_newName) {\n      return function wrappedPointCut() {\n        var args = [].slice.call(arguments);\n        var lastArg = args.pop();\n        var fn;\n        var originalError = new Error();\n        var $results;\n        if (lastArg && typeof lastArg !== 'function') {\n          args.push(lastArg);\n        } else {\n          fn = lastArg;\n        }\n\n        var promise = new Promise.ES6(function(resolve, reject) {\n          args.push(function(error) {\n            if (error) {\n              // gh-2633: since VersionError is very generic, take the\n              // stack trace of the original save() function call rather\n              // than the async trace\n              if (error instanceof VersionError) {\n                error.stack = originalError.stack;\n              }\n              _this.$__handleReject(error);\n              reject(error);\n              return;\n            }\n\n            // There may be multiple results and promise libs other than\n            // mpromise don't support passing multiple values to `resolve()`\n            $results = Array.prototype.slice.call(arguments, 1);\n            resolve.apply(promise, $results);\n          });\n\n          _this[_newName].apply(_this, args);\n        });\n        if (fn) {\n          if (_this.constructor.$wrapCallback) {\n            fn = _this.constructor.$wrapCallback(fn);\n          }\n          return promise.then(\n            function() {\n              process.nextTick(function() {\n                fn.apply(null, [null].concat($results));\n              });\n            },\n            function(error) {\n              process.nextTick(function() {\n                fn(error);\n              });\n            });\n        }\n        return promise;\n      };\n    })(newName);\n    _this[pointCut].$isWrapped = true;\n\n    toWrapEl = toWrap[pointCut];\n    var _len = toWrapEl.pre.length;\n    args;\n    for (j = 0; j < _len; ++j) {\n      args = toWrapEl.pre[j];\n      args[0] = newName;\n      _this.$pre.apply(_this, args);\n    }\n\n    _len = toWrapEl.post.length;\n    for (j = 0; j < _len; ++j) {\n      args = toWrapEl.post[j];\n      args[0] = newName;\n      _this.$post.apply(_this, args);\n    }\n  }\n  return _this;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n"]},"metadata":{},"sourceType":"script"}