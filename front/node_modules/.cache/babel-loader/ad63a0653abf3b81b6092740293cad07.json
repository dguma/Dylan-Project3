{"ast":null,"code":"/*!\n * Module dependencies.\n */\nvar $exists = require('./operators/exists');\n\nvar $type = require('./operators/type');\n\nvar SchemaType = require('../schematype');\n\nvar CastError = SchemaType.CastError;\nvar Types = {\n  Array: SchemaArray,\n  Boolean: require('./boolean'),\n  Date: require('./date'),\n  Number: require('./number'),\n  String: require('./string'),\n  ObjectId: require('./objectid'),\n  Buffer: require('./buffer')\n};\n\nvar Mixed = require('./mixed');\n\nvar cast = require('../cast');\n\nvar util = require('util');\n\nvar utils = require('../utils');\n\nvar castToNumber = require('./operators/helpers').castToNumber;\n\nvar geospatial = require('./operators/geospatial');\n\nvar MongooseArray;\nvar EmbeddedDoc;\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n  var typeKey = 'type';\n\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n\n  if (cast) {\n    var castOptions = {};\n\n    if (utils.getFunctionName(cast.constructor) === 'Object') {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    } // support { type: 'String' }\n\n\n    var name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n    var caster = name in Types ? Types[name] : cast;\n    this.casterConstructor = caster;\n\n    if (typeof caster === 'function' && !caster.$isArraySubdocument) {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  this.$isMongooseArray = true;\n  SchemaType.call(this, key, options, 'Array');\n  var defaultArr;\n  var fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    this.default(function () {\n      var arr = [];\n\n      if (fn) {\n        arr = defaultArr();\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      } // Leave it up to `cast()` to convert the array\n\n\n      return arr;\n    });\n  }\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nSchemaArray.schemaName = 'Array';\n/*!\n * Inherits from SchemaType.\n */\n\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\n/**\n * Check if the given value satisfies a required validator. The given value\n * must be not null nor undefined, and have a positive length.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function (value) {\n  return !!(value && value.length);\n};\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\n\nSchemaArray.prototype.cast = function (value, doc, init) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      var indexes = doc.schema.indexedPaths();\n\n      for (var i = 0, l = indexes.length; i < l; ++i) {\n        var pathIndex = indexes[i][0][this.path];\n\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this.path, doc);\n    }\n\n    if (this.caster) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          value[i] = this.caster.cast(value[i], doc, init);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);\n      }\n    }\n\n    return value;\n  } // gh-2442: if we're loading this from the db and its not an array, mark\n  // the whole array as modified.\n\n\n  if (!!doc && !!init) {\n    doc.markModified(this.path);\n  }\n\n  return this.cast([value], doc, init);\n};\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\n\nSchemaArray.prototype.castForQuery = function ($conditional, value) {\n  var handler, val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    var Constructor = this.casterConstructor;\n\n    if (val && Constructor.discriminators && Constructor.schema.options.discriminatorKey && typeof val[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    }\n\n    var proto = this.casterConstructor.prototype;\n    var method = proto && (proto.castForQuery || proto.cast);\n\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n\n    var caster = this.caster;\n\n    if (Array.isArray(val)) {\n      val = val.map(function (v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function (v) {\n    if (utils.isObject(v)) {\n      var o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n\n    return v;\n  }, this);\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  var keys = Object.keys(val);\n  var numKeys = keys.length;\n  var key;\n  var value;\n\n  for (var i = 0; i < numKeys; ++i) {\n    key = keys[i];\n    value = val[key];\n\n    if (key.indexOf('$') === 0 && value) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nvar handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\n\nhandle.$or = handle.$and = function (val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  var ret = [];\n\n  for (var i = 0; i < val.length; ++i) {\n    ret.push(cast(this.casterConstructor.schema, val[i]));\n  }\n\n  return ret;\n};\n\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$exists = $exists;\nhandle.$type = $type;\nhandle.$eq = handle.$gt = handle.$gte = handle.$in = handle.$lt = handle.$lte = handle.$ne = handle.$nin = handle.$regex = SchemaArray.prototype.castForQuery;\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/mongoose/lib/schema/array.js"],"names":["$exists","require","$type","SchemaType","CastError","Types","Array","SchemaArray","Boolean","Date","Number","String","ObjectId","Buffer","Mixed","cast","util","utils","castToNumber","geospatial","MongooseArray","EmbeddedDoc","key","options","schemaOptions","Embedded","typeKey","castOptions","getFunctionName","constructor","clone","name","caster","casterConstructor","$isArraySubdocument","path","$isMongooseArray","call","defaultArr","fn","defaultValue","default","arr","concat","schemaName","prototype","Object","create","checkRequired","value","length","applyGetters","scope","ref","doc","init","isArray","indexes","schema","indexedPaths","i","l","pathIndex","isMongooseArray","e","kind","inspect","markModified","castForQuery","$conditional","handler","val","arguments","$conditionalHandlers","Error","Constructor","discriminators","discriminatorKey","proto","method","map","v","isObject","$elemMatch","cast$all","o","cast$elemMatch","keys","numKeys","indexOf","handle","$all","$options","$geoIntersects","cast$geoIntersects","$or","$and","TypeError","ret","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$in","$lt","$lte","$ne","$nin","$regex","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Module dependencies.\n */\n\nvar $exists = require('./operators/exists');\nvar $type = require('./operators/type');\nvar SchemaType = require('../schematype');\nvar CastError = SchemaType.CastError;\nvar Types = {\n  Array: SchemaArray,\n  Boolean: require('./boolean'),\n  Date: require('./date'),\n  Number: require('./number'),\n  String: require('./string'),\n  ObjectId: require('./objectid'),\n  Buffer: require('./buffer')\n};\nvar Mixed = require('./mixed');\nvar cast = require('../cast');\nvar util = require('util');\nvar utils = require('../utils');\nvar castToNumber = require('./operators/helpers').castToNumber;\nvar geospatial = require('./operators/geospatial');\n\nvar MongooseArray;\nvar EmbeddedDoc;\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  var typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n\n  if (cast) {\n    var castOptions = {};\n\n    if (utils.getFunctionName(cast.constructor) === 'Object') {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    // support { type: 'String' }\n    var name = typeof cast === 'string'\n        ? cast\n        : utils.getFunctionName(cast);\n\n    var caster = name in Types\n        ? Types[name]\n        : cast;\n\n    this.casterConstructor = caster;\n    if (typeof caster === 'function' && !caster.$isArraySubdocument) {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  var defaultArr;\n  var fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    this.default(function() {\n      var arr = [];\n      if (fn) {\n        arr = defaultArr();\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      }\n      // Leave it up to `cast()` to convert the array\n      return arr;\n    });\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\n\n/**\n * Check if the given value satisfies a required validator. The given value\n * must be not null nor undefined, and have a positive length.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function(value) {\n  return !!(value && value.length);\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      var indexes = doc.schema.indexedPaths();\n\n      for (var i = 0, l = indexes.length; i < l; ++i) {\n        var pathIndex = indexes[i][0][this.path];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this.path, doc);\n    }\n\n    if (this.caster) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          value[i] = this.caster.cast(value[i], doc, init);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);\n      }\n    }\n\n    return value;\n  }\n  // gh-2442: if we're loading this from the db and its not an array, mark\n  // the whole array as modified.\n  if (!!doc && !!init) {\n    doc.markModified(this.path);\n  }\n  return this.cast([value], doc, init);\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, value) {\n  var handler,\n      val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    var Constructor = this.casterConstructor;\n\n    if (val &&\n        Constructor.discriminators &&\n        Constructor.schema.options.discriminatorKey &&\n        typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    }\n\n    var proto = this.casterConstructor.prototype;\n    var method = proto && (proto.castForQuery || proto.cast);\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n    var caster = this.caster;\n\n    if (Array.isArray(val)) {\n      val = val.map(function(v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function(v) {\n    if (utils.isObject(v)) {\n      var o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n    return v;\n  }, this);\n\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  var keys = Object.keys(val);\n  var numKeys = keys.length;\n  var key;\n  var value;\n  for (var i = 0; i < numKeys; ++i) {\n    key = keys[i];\n    value = val[key];\n    if (key.indexOf('$') === 0 && value) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nvar handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = handle.$and = function(val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  var ret = [];\n  for (var i = 0; i < val.length; ++i) {\n    ret.push(cast(this.casterConstructor.schema, val[i]));\n  }\n\n  return ret;\n};\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$in =\nhandle.$lt =\nhandle.$lte =\nhandle.$ne =\nhandle.$nin =\nhandle.$regex = SchemaArray.prototype.castForQuery;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"]},"metadata":{},"sourceType":"script"}