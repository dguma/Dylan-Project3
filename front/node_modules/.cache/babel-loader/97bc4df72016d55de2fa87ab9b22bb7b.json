{"ast":null,"code":"/*!\n * Module dependencies.\n */\nvar EmbeddedDocument = require('./embedded');\n\nvar Document = require('../document');\n\nvar ObjectId = require('./objectid');\n\nvar cleanModifiedSubpaths = require('../services/document/cleanModifiedSubpaths');\n\nvar utils = require('../utils');\n\nvar isMongooseObject = utils.isMongooseObject;\n/**\n * Mongoose Array constructor.\n *\n * ####NOTE:\n *\n * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._\n *\n * @param {Array} values\n * @param {String} path\n * @param {Document} doc parent document\n * @api private\n * @inherits Array\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseArray(values, path, doc) {\n  var arr = [].concat(values);\n  var keysMA = Object.keys(MongooseArray.mixin);\n  var numKeys = keysMA.length;\n\n  for (var i = 0; i < numKeys; ++i) {\n    arr[keysMA[i]] = MongooseArray.mixin[keysMA[i]];\n  }\n\n  arr._path = path;\n  arr.isMongooseArray = true;\n  arr.validators = [];\n  arr._atomics = {};\n  arr._schema = void 0; // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n\n  if (doc && doc instanceof Document) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n  }\n\n  return arr;\n}\n\nMongooseArray.mixin = {\n  /*!\n   * ignore\n   */\n  toBSON: function () {\n    return this.toObject({\n      transform: false,\n      virtuals: false,\n      _skipDepopulateTopLevel: true,\n      depopulate: true,\n      flattenDecimals: false\n    });\n  },\n\n  /**\n   * Stores a queue of atomic operations to perform\n   *\n   * @property _atomics\n   * @api private\n   */\n  _atomics: undefined,\n\n  /**\n   * Parent owner document\n   *\n   * @property _parent\n   * @api private\n   * @receiver MongooseArray\n   */\n  _parent: undefined,\n\n  /**\n   * Casts a member based on this arrays schema.\n   *\n   * @param {any} value\n   * @return value the casted value\n   * @method _cast\n   * @api private\n   * @receiver MongooseArray\n   */\n  _cast: function (value) {\n    var populated = false;\n    var Model;\n\n    if (this._parent) {\n      populated = this._parent.populated(this._path, true);\n    }\n\n    if (populated && value !== null && value !== undefined) {\n      // cast to the populated Models schema\n      Model = populated.options.model || populated.options.Model; // only objects are permitted so we can safely assume that\n      // non-objects are to be interpreted as _id\n\n      if (Buffer.isBuffer(value) || value instanceof ObjectId || !utils.isObject(value)) {\n        value = {\n          _id: value\n        };\n      } // gh-2399\n      // we should cast model only when it's not a discriminator\n\n\n      var isDisc = value.schema && value.schema.discriminatorMapping && value.schema.discriminatorMapping.key !== undefined;\n\n      if (!isDisc) {\n        value = new Model(value);\n      }\n\n      return this._schema.caster.applySetters(value, this._parent, true);\n    }\n\n    return this._schema.caster.applySetters(value, this._parent, false);\n  },\n\n  /**\n   * Marks this array as modified.\n   *\n   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n   *\n   * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array\n   * @param {String} embeddedPath the path which changed in the embeddedDoc\n   * @method _markModified\n   * @api private\n   * @receiver MongooseArray\n   */\n  _markModified: function (elem, embeddedPath) {\n    var parent = this._parent,\n        dirtyPath;\n\n    if (parent) {\n      dirtyPath = this._path;\n\n      if (arguments.length) {\n        if (embeddedPath != null) {\n          // an embedded doc bubbled up the change\n          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;\n        } else {\n          // directly set an index\n          dirtyPath = dirtyPath + '.' + elem;\n        }\n      }\n\n      parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an atomic operation with the parent.\n   *\n   * @param {Array} op operation\n   * @param {any} val\n   * @method _registerAtomic\n   * @api private\n   * @receiver MongooseArray\n   */\n  _registerAtomic: function (op, val) {\n    if (op === '$set') {\n      // $set takes precedence over all other ops.\n      // mark entire array modified.\n      this._atomics = {\n        $set: val\n      };\n      return this;\n    }\n\n    var atomics = this._atomics; // reset pop/shift after save\n\n    if (op === '$pop' && !('$pop' in atomics)) {\n      var _this = this;\n\n      this._parent.once('save', function () {\n        _this._popped = _this._shifted = null;\n      });\n    } // check for impossible $atomic combos (Mongo denies more than one\n    // $atomic op on a single path\n\n\n    if (this._atomics.$set || Object.keys(atomics).length && !(op in atomics)) {\n      // a different op was previously registered.\n      // save the entire thing.\n      this._atomics = {\n        $set: this\n      };\n      return this;\n    }\n\n    var selector;\n\n    if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') {\n      atomics[op] || (atomics[op] = []);\n      atomics[op] = atomics[op].concat(val);\n    } else if (op === '$pullDocs') {\n      var pullOp = atomics['$pull'] || (atomics['$pull'] = {});\n\n      if (val[0] instanceof EmbeddedDocument) {\n        selector = pullOp['$or'] || (pullOp['$or'] = []);\n        Array.prototype.push.apply(selector, val.map(function (v) {\n          return v.toObject({\n            transform: false,\n            virtuals: false\n          });\n        }));\n      } else {\n        selector = pullOp['_id'] || (pullOp['_id'] = {\n          $in: []\n        });\n        selector['$in'] = selector['$in'].concat(val);\n      }\n    } else {\n      atomics[op] = val;\n    }\n\n    return this;\n  },\n\n  /**\n   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.\n   *\n   * If no atomics exist, we return all array values after conversion.\n   *\n   * @return {Array}\n   * @method $__getAtomics\n   * @memberOf MongooseArray\n   * @api private\n   */\n  $__getAtomics: function () {\n    var ret = [];\n    var keys = Object.keys(this._atomics);\n    var i = keys.length;\n\n    if (i === 0) {\n      ret[0] = ['$set', this.toObject({\n        depopulate: 1,\n        transform: false,\n        _isNested: true,\n        virtuals: false\n      })];\n      return ret;\n    }\n\n    while (i--) {\n      var op = keys[i];\n      var val = this._atomics[op]; // the atomic values which are arrays are not MongooseArrays. we\n      // need to convert their elements as if they were MongooseArrays\n      // to handle populated arrays versus DocumentArrays properly.\n\n      if (isMongooseObject(val)) {\n        val = val.toObject({\n          depopulate: 1,\n          transform: false,\n          _isNested: true,\n          virtuals: false\n        });\n      } else if (Array.isArray(val)) {\n        val = this.toObject.call(val, {\n          depopulate: 1,\n          transform: false,\n          _isNested: true\n        });\n      } else if (val.valueOf) {\n        val = val.valueOf();\n      }\n\n      if (op === '$addToSet') {\n        val = {\n          $each: val\n        };\n      }\n\n      ret.push([op, val]);\n    }\n\n    return ret;\n  },\n\n  /**\n   * Returns the number of pending atomic operations to send to the db for this array.\n   *\n   * @api private\n   * @return {Number}\n   * @method hasAtomics\n   * @receiver MongooseArray\n   */\n  hasAtomics: function hasAtomics() {\n    if (!(this._atomics && this._atomics.constructor.name === 'Object')) {\n      return 0;\n    }\n\n    return Object.keys(this._atomics).length;\n  },\n\n  /**\n   * Internal helper for .map()\n   *\n   * @api private\n   * @return {Number}\n   * @method _mapCast\n   * @receiver MongooseArray\n   */\n  _mapCast: function (val, index) {\n    return this._cast(val, this.length + index);\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * @param {Object} [args...]\n   * @api public\n   * @method push\n   * @receiver MongooseArray\n   */\n  push: function () {\n    _checkManualPopulation(this, arguments);\n\n    var values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent, undefined, undefined, {\n      skipDocumentArrayCast: true\n    });\n    var ret = [].push.apply(this, values); // $pushAll might be fibbed (could be $push). But it makes it easier to\n    // handle what could have been $push, $pushAll combos\n\n    this._registerAtomic('$pushAll', values);\n\n    this._markModified();\n\n    return ret;\n  },\n\n  /**\n   * Pushes items to the array non-atomically.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @param {any} [args...]\n   * @api public\n   * @method nonAtomicPush\n   * @receiver MongooseArray\n   */\n  nonAtomicPush: function () {\n    var values = [].map.call(arguments, this._mapCast, this);\n    var ret = [].push.apply(this, values);\n\n    this._registerAtomic('$set', this);\n\n    this._markModified();\n\n    return ret;\n  },\n\n  /**\n   * Pops the array atomically at most one time per document `save()`.\n   *\n   * #### NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var popped = doc.array.$pop();\n   *      console.log(popped); // 3\n   *      console.log(doc.array); // [1,2]\n   *\n   *      // no affect\n   *      popped = doc.array.$pop();\n   *      console.log(doc.array); // [1,2]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $pop works again\n   *        popped = doc.array.$pop();\n   *        console.log(popped); // 2\n   *        console.log(doc.array); // [1]\n   *      })\n   *\n   * @api public\n   * @method $pop\n   * @memberOf MongooseArray\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   * @method $pop\n   * @receiver MongooseArray\n   */\n  $pop: function () {\n    this._registerAtomic('$pop', 1);\n\n    this._markModified(); // only allow popping once\n\n\n    if (this._popped) {\n      return;\n    }\n\n    this._popped = true;\n    return [].pop.call(this);\n  },\n\n  /**\n   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @see MongooseArray#$pop #types_array_MongooseArray-%24pop\n   * @api public\n   * @method pop\n   * @receiver MongooseArray\n   */\n  pop: function () {\n    var ret = [].pop.call(this);\n\n    this._registerAtomic('$set', this);\n\n    this._markModified();\n\n    return ret;\n  },\n\n  /**\n   * Atomically shifts the array at most one time per document `save()`.\n   *\n   * ####NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var shifted = doc.array.$shift();\n   *      console.log(shifted); // 1\n   *      console.log(doc.array); // [2,3]\n   *\n   *      // no affect\n   *      shifted = doc.array.$shift();\n   *      console.log(doc.array); // [2,3]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $shift works again\n   *        shifted = doc.array.$shift();\n   *        console.log(shifted ); // 2\n   *        console.log(doc.array); // [3]\n   *      })\n   *\n   * @api public\n   * @memberOf MongooseArray\n   * @method $shift\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   */\n  $shift: function $shift() {\n    this._registerAtomic('$pop', -1);\n\n    this._markModified(); // only allow shifting once\n\n\n    if (this._shifted) {\n      return;\n    }\n\n    this._shifted = true;\n    return [].shift.call(this);\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Example:\n   *\n   *     doc.array = [2,3];\n   *     var res = doc.array.shift();\n   *     console.log(res) // 2\n   *     console.log(doc.array) // [3]\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method shift\n   * @receiver MongooseArray\n   */\n  shift: function () {\n    var ret = [].shift.call(this);\n\n    this._registerAtomic('$set', this);\n\n    this._markModified();\n\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically. Equality is determined by casting\n   * the provided value to an embedded document and comparing using\n   * [the `Document.equals()` function.](./api.html#document_Document-equals)\n   *\n   * ####Examples:\n   *\n   *     doc.array.pull(ObjectId)\n   *     doc.array.pull({ _id: 'someId' })\n   *     doc.array.pull(36)\n   *     doc.array.pull('tag 1', 'tag 2')\n   *\n   * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n   *\n   * Or we may passing the _id directly and let mongoose take care of it.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull(4815162342); // works\n   *\n   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n   *\n   * @param {any} [args...]\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n   * @api public\n   * @method pull\n   * @receiver MongooseArray\n   */\n  pull: function () {\n    var values = [].map.call(arguments, this._cast, this),\n        cur = this._parent.get(this._path),\n        i = cur.length,\n        mem;\n\n    while (i--) {\n      mem = cur[i];\n\n      if (mem instanceof Document) {\n        var some = values.some(function (v) {\n          return mem.equals(v);\n        });\n\n        if (some) {\n          [].splice.call(cur, i, 1);\n        }\n      } else if (~cur.indexOf.call(values, mem)) {\n        [].splice.call(cur, i, 1);\n      }\n    }\n\n    if (values[0] instanceof EmbeddedDocument) {\n      this._registerAtomic('$pullDocs', values.map(function (v) {\n        return v._id || v;\n      }));\n    } else {\n      this._registerAtomic('$pullAll', values);\n    }\n\n    this._markModified(); // Might have modified child paths and then pulled, like\n    // `doc.children[1].name = 'test';` followed by\n    // `doc.children.remove(doc.children[0]);`. In this case we fall back\n    // to a `$set` on the whole array. See #3511\n\n\n    if (cleanModifiedSubpaths(this._parent, this._path) > 0) {\n      this._registerAtomic('$set', this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method splice\n   * @receiver MongooseArray\n   */\n  splice: function splice() {\n    var ret;\n    var vals;\n    var i;\n\n    _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));\n\n    if (arguments.length) {\n      vals = [];\n\n      for (i = 0; i < arguments.length; ++i) {\n        vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2));\n      }\n\n      ret = [].splice.apply(this, vals);\n\n      this._registerAtomic('$set', this);\n\n      this._markModified();\n    }\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method unshift\n   * @receiver MongooseArray\n   */\n  unshift: function () {\n    _checkManualPopulation(this, arguments);\n\n    var values = [].map.call(arguments, this._cast, this);\n    values = this._schema.applySetters(values, this._parent);\n    [].unshift.apply(this, values);\n\n    this._registerAtomic('$set', this);\n\n    this._markModified();\n\n    return this.length;\n  },\n\n  /**\n   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method sort\n   * @receiver MongooseArray\n   */\n  sort: function () {\n    var ret = [].sort.apply(this, arguments);\n\n    this._registerAtomic('$set', this);\n\n    this._markModified();\n\n    return ret;\n  },\n\n  /**\n   * Adds values to the array if not already present.\n   *\n   * ####Example:\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *     var added = doc.array.addToSet(4,5);\n   *     console.log(doc.array) // [2,3,4,5]\n   *     console.log(added)     // [5]\n   *\n   * @param {any} [args...]\n   * @return {Array} the values that were added\n   * @receiver MongooseArray\n   * @api public\n   * @method addToSet\n   */\n  addToSet: function addToSet() {\n    _checkManualPopulation(this, arguments);\n\n    var values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent);\n    var added = [];\n    var type = '';\n\n    if (values[0] instanceof EmbeddedDocument) {\n      type = 'doc';\n    } else if (values[0] instanceof Date) {\n      type = 'date';\n    }\n\n    values.forEach(function (v) {\n      var found;\n\n      switch (type) {\n        case 'doc':\n          found = this.some(function (doc) {\n            return doc.equals(v);\n          });\n          break;\n\n        case 'date':\n          var val = +v;\n          found = this.some(function (d) {\n            return +d === val;\n          });\n          break;\n\n        default:\n          found = ~this.indexOf(v);\n      }\n\n      if (!found) {\n        [].push.call(this, v);\n\n        this._registerAtomic('$addToSet', v);\n\n        this._markModified();\n\n        [].push.call(added, v);\n      }\n    }, this);\n    return added;\n  },\n\n  /**\n   * Sets the casted `val` at index `i` and marks the array modified.\n   *\n   * ####Example:\n   *\n   *     // given documents based on the following\n   *     var Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n   *\n   *     var doc = new Doc({ array: [2,3,4] })\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *\n   *     doc.array.set(1,\"5\");\n   *     console.log(doc.array); // [2,5,4] // properly cast to number\n   *     doc.save() // the change is saved\n   *\n   *     // VS not using array#set\n   *     doc.array[1] = \"5\";\n   *     console.log(doc.array); // [2,\"5\",4] // no casting\n   *     doc.save() // change is not saved\n   *\n   * @return {Array} this\n   * @api public\n   * @method set\n   * @receiver MongooseArray\n   */\n  set: function set(i, val) {\n    var value = this._cast(val, i);\n\n    this[i] = value;\n\n    this._markModified(i);\n\n    return this;\n  },\n\n  /**\n   * Returns a native js Array.\n   *\n   * @param {Object} options\n   * @return {Array}\n   * @api public\n   * @method toObject\n   * @receiver MongooseArray\n   */\n  toObject: function (options) {\n    if (options && options.depopulate) {\n      options._isNested = true;\n      return this.map(function (doc) {\n        return doc instanceof Document ? doc.toObject(options) : doc;\n      });\n    }\n\n    return this.slice();\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @api public\n   * @method inspect\n   * @receiver MongooseArray\n   */\n  inspect: function () {\n    return JSON.stringify(this);\n  },\n\n  /**\n   * Return the index of `obj` or `-1` if not found.\n   *\n   * @param {Object} obj the item to look for\n   * @return {Number}\n   * @api public\n   * @method indexOf\n   * @receiver MongooseArray\n   */\n  indexOf: function indexOf(obj) {\n    if (obj instanceof ObjectId) {\n      obj = obj.toString();\n    }\n\n    for (var i = 0, len = this.length; i < len; ++i) {\n      if (obj == this[i]) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n};\n/**\n * Alias of [pull](#types_array_MongooseArray-pull)\n *\n * @see MongooseArray#pull #types_array_MongooseArray-pull\n * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n * @api public\n * @memberOf MongooseArray\n * @method remove\n */\n\nMongooseArray.mixin.remove = MongooseArray.mixin.pull;\n/*!\n * ignore\n */\n\nfunction _isAllSubdocs(docs, ref) {\n  if (!ref) {\n    return false;\n  }\n\n  for (var i = 0; i < docs.length; ++i) {\n    var arg = docs[i];\n\n    if (arg == null) {\n      return false;\n    }\n\n    var model = arg.constructor;\n\n    if (!(arg instanceof Document) || model.modelName !== ref && model.baseModelName !== ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*!\n * ignore\n */\n\n\nfunction _checkManualPopulation(arr, docs) {\n  var ref = arr._schema.caster.options && arr._schema.caster.options.ref;\n\n  if (arr.length === 0 && docs.length > 0) {\n    if (_isAllSubdocs(docs, ref)) {\n      arr._parent.populated(arr._path, [], {\n        model: docs[0].constructor\n      });\n    }\n  }\n}\n/*!\n * Module exports.\n */\n\n\nmodule.exports = exports = MongooseArray;","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/mongoose/lib/types/array.js"],"names":["EmbeddedDocument","require","Document","ObjectId","cleanModifiedSubpaths","utils","isMongooseObject","MongooseArray","values","path","doc","arr","concat","keysMA","Object","keys","mixin","numKeys","length","i","_path","isMongooseArray","validators","_atomics","_schema","_parent","schema","toBSON","toObject","transform","virtuals","_skipDepopulateTopLevel","depopulate","flattenDecimals","undefined","_cast","value","populated","Model","options","model","Buffer","isBuffer","isObject","_id","isDisc","discriminatorMapping","key","caster","applySetters","_markModified","elem","embeddedPath","parent","dirtyPath","arguments","indexOf","markModified","_registerAtomic","op","val","$set","atomics","_this","once","_popped","_shifted","selector","pullOp","Array","prototype","push","apply","map","v","$in","$__getAtomics","ret","_isNested","isArray","call","valueOf","$each","hasAtomics","constructor","name","_mapCast","index","_checkManualPopulation","skipDocumentArrayCast","nonAtomicPush","$pop","pop","$shift","shift","pull","cur","get","mem","some","equals","splice","vals","slice","unshift","sort","addToSet","added","type","Date","forEach","found","d","set","inspect","JSON","stringify","obj","toString","len","remove","_isAllSubdocs","docs","ref","arg","modelName","baseModelName","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Module dependencies.\n */\n\nvar EmbeddedDocument = require('./embedded');\nvar Document = require('../document');\nvar ObjectId = require('./objectid');\nvar cleanModifiedSubpaths = require('../services/document/cleanModifiedSubpaths');\nvar utils = require('../utils');\n\nvar isMongooseObject = utils.isMongooseObject;\n\n/**\n * Mongoose Array constructor.\n *\n * ####NOTE:\n *\n * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._\n *\n * @param {Array} values\n * @param {String} path\n * @param {Document} doc parent document\n * @api private\n * @inherits Array\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseArray(values, path, doc) {\n  var arr = [].concat(values);\n\n  var keysMA = Object.keys(MongooseArray.mixin);\n  var numKeys = keysMA.length;\n  for (var i = 0; i < numKeys; ++i) {\n    arr[keysMA[i]] = MongooseArray.mixin[keysMA[i]];\n  }\n\n  arr._path = path;\n  arr.isMongooseArray = true;\n  arr.validators = [];\n  arr._atomics = {};\n  arr._schema = void 0;\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc && doc instanceof Document) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n  }\n\n  return arr;\n}\n\nMongooseArray.mixin = {\n  /*!\n   * ignore\n   */\n  toBSON: function() {\n    return this.toObject({\n      transform: false,\n      virtuals: false,\n      _skipDepopulateTopLevel: true,\n      depopulate: true,\n      flattenDecimals: false\n    });\n  },\n\n  /**\n   * Stores a queue of atomic operations to perform\n   *\n   * @property _atomics\n   * @api private\n   */\n\n  _atomics: undefined,\n\n  /**\n   * Parent owner document\n   *\n   * @property _parent\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _parent: undefined,\n\n  /**\n   * Casts a member based on this arrays schema.\n   *\n   * @param {any} value\n   * @return value the casted value\n   * @method _cast\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _cast: function(value) {\n    var populated = false;\n    var Model;\n\n    if (this._parent) {\n      populated = this._parent.populated(this._path, true);\n    }\n\n    if (populated && value !== null && value !== undefined) {\n      // cast to the populated Models schema\n      Model = populated.options.model || populated.options.Model;\n\n      // only objects are permitted so we can safely assume that\n      // non-objects are to be interpreted as _id\n      if (Buffer.isBuffer(value) ||\n          value instanceof ObjectId || !utils.isObject(value)) {\n        value = {_id: value};\n      }\n\n      // gh-2399\n      // we should cast model only when it's not a discriminator\n      var isDisc = value.schema && value.schema.discriminatorMapping &&\n          value.schema.discriminatorMapping.key !== undefined;\n      if (!isDisc) {\n        value = new Model(value);\n      }\n      return this._schema.caster.applySetters(value, this._parent, true);\n    }\n\n    return this._schema.caster.applySetters(value, this._parent, false);\n  },\n\n  /**\n   * Marks this array as modified.\n   *\n   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n   *\n   * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array\n   * @param {String} embeddedPath the path which changed in the embeddedDoc\n   * @method _markModified\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _markModified: function(elem, embeddedPath) {\n    var parent = this._parent,\n        dirtyPath;\n\n    if (parent) {\n      dirtyPath = this._path;\n\n      if (arguments.length) {\n        if (embeddedPath != null) {\n          // an embedded doc bubbled up the change\n          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;\n        } else {\n          // directly set an index\n          dirtyPath = dirtyPath + '.' + elem;\n        }\n      }\n\n      parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an atomic operation with the parent.\n   *\n   * @param {Array} op operation\n   * @param {any} val\n   * @method _registerAtomic\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _registerAtomic: function(op, val) {\n    if (op === '$set') {\n      // $set takes precedence over all other ops.\n      // mark entire array modified.\n      this._atomics = {$set: val};\n      return this;\n    }\n\n    var atomics = this._atomics;\n\n    // reset pop/shift after save\n    if (op === '$pop' && !('$pop' in atomics)) {\n      var _this = this;\n      this._parent.once('save', function() {\n        _this._popped = _this._shifted = null;\n      });\n    }\n\n    // check for impossible $atomic combos (Mongo denies more than one\n    // $atomic op on a single path\n    if (this._atomics.$set ||\n        Object.keys(atomics).length && !(op in atomics)) {\n      // a different op was previously registered.\n      // save the entire thing.\n      this._atomics = {$set: this};\n      return this;\n    }\n\n    var selector;\n\n    if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') {\n      atomics[op] || (atomics[op] = []);\n      atomics[op] = atomics[op].concat(val);\n    } else if (op === '$pullDocs') {\n      var pullOp = atomics['$pull'] || (atomics['$pull'] = {});\n      if (val[0] instanceof EmbeddedDocument) {\n        selector = pullOp['$or'] || (pullOp['$or'] = []);\n        Array.prototype.push.apply(selector, val.map(function(v) {\n          return v.toObject({transform: false, virtuals: false});\n        }));\n      } else {\n        selector = pullOp['_id'] || (pullOp['_id'] = {$in: []});\n        selector['$in'] = selector['$in'].concat(val);\n      }\n    } else {\n      atomics[op] = val;\n    }\n\n    return this;\n  },\n\n  /**\n   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.\n   *\n   * If no atomics exist, we return all array values after conversion.\n   *\n   * @return {Array}\n   * @method $__getAtomics\n   * @memberOf MongooseArray\n   * @api private\n   */\n\n  $__getAtomics: function() {\n    var ret = [];\n    var keys = Object.keys(this._atomics);\n    var i = keys.length;\n\n    if (i === 0) {\n      ret[0] = ['$set', this.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false})];\n      return ret;\n    }\n\n    while (i--) {\n      var op = keys[i];\n      var val = this._atomics[op];\n\n      // the atomic values which are arrays are not MongooseArrays. we\n      // need to convert their elements as if they were MongooseArrays\n      // to handle populated arrays versus DocumentArrays properly.\n      if (isMongooseObject(val)) {\n        val = val.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false});\n      } else if (Array.isArray(val)) {\n        val = this.toObject.call(val, {depopulate: 1, transform: false, _isNested: true});\n      } else if (val.valueOf) {\n        val = val.valueOf();\n      }\n\n      if (op === '$addToSet') {\n        val = {$each: val};\n      }\n\n      ret.push([op, val]);\n    }\n\n    return ret;\n  },\n\n  /**\n   * Returns the number of pending atomic operations to send to the db for this array.\n   *\n   * @api private\n   * @return {Number}\n   * @method hasAtomics\n   * @receiver MongooseArray\n   */\n\n  hasAtomics: function hasAtomics() {\n    if (!(this._atomics && this._atomics.constructor.name === 'Object')) {\n      return 0;\n    }\n\n    return Object.keys(this._atomics).length;\n  },\n\n  /**\n   * Internal helper for .map()\n   *\n   * @api private\n   * @return {Number}\n   * @method _mapCast\n   * @receiver MongooseArray\n   */\n  _mapCast: function(val, index) {\n    return this._cast(val, this.length + index);\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * @param {Object} [args...]\n   * @api public\n   * @method push\n   * @receiver MongooseArray\n   */\n\n  push: function() {\n    _checkManualPopulation(this, arguments);\n    var values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent, undefined,\n        undefined, { skipDocumentArrayCast: true });\n    var ret = [].push.apply(this, values);\n\n    // $pushAll might be fibbed (could be $push). But it makes it easier to\n    // handle what could have been $push, $pushAll combos\n    this._registerAtomic('$pushAll', values);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pushes items to the array non-atomically.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @param {any} [args...]\n   * @api public\n   * @method nonAtomicPush\n   * @receiver MongooseArray\n   */\n\n  nonAtomicPush: function() {\n    var values = [].map.call(arguments, this._mapCast, this);\n    var ret = [].push.apply(this, values);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pops the array atomically at most one time per document `save()`.\n   *\n   * #### NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var popped = doc.array.$pop();\n   *      console.log(popped); // 3\n   *      console.log(doc.array); // [1,2]\n   *\n   *      // no affect\n   *      popped = doc.array.$pop();\n   *      console.log(doc.array); // [1,2]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $pop works again\n   *        popped = doc.array.$pop();\n   *        console.log(popped); // 2\n   *        console.log(doc.array); // [1]\n   *      })\n   *\n   * @api public\n   * @method $pop\n   * @memberOf MongooseArray\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   * @method $pop\n   * @receiver MongooseArray\n   */\n\n  $pop: function() {\n    this._registerAtomic('$pop', 1);\n    this._markModified();\n\n    // only allow popping once\n    if (this._popped) {\n      return;\n    }\n    this._popped = true;\n\n    return [].pop.call(this);\n  },\n\n  /**\n   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @see MongooseArray#$pop #types_array_MongooseArray-%24pop\n   * @api public\n   * @method pop\n   * @receiver MongooseArray\n   */\n\n  pop: function() {\n    var ret = [].pop.call(this);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Atomically shifts the array at most one time per document `save()`.\n   *\n   * ####NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var shifted = doc.array.$shift();\n   *      console.log(shifted); // 1\n   *      console.log(doc.array); // [2,3]\n   *\n   *      // no affect\n   *      shifted = doc.array.$shift();\n   *      console.log(doc.array); // [2,3]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $shift works again\n   *        shifted = doc.array.$shift();\n   *        console.log(shifted ); // 2\n   *        console.log(doc.array); // [3]\n   *      })\n   *\n   * @api public\n   * @memberOf MongooseArray\n   * @method $shift\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   */\n\n  $shift: function $shift() {\n    this._registerAtomic('$pop', -1);\n    this._markModified();\n\n    // only allow shifting once\n    if (this._shifted) {\n      return;\n    }\n    this._shifted = true;\n\n    return [].shift.call(this);\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Example:\n   *\n   *     doc.array = [2,3];\n   *     var res = doc.array.shift();\n   *     console.log(res) // 2\n   *     console.log(doc.array) // [3]\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method shift\n   * @receiver MongooseArray\n   */\n\n  shift: function() {\n    var ret = [].shift.call(this);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically. Equality is determined by casting\n   * the provided value to an embedded document and comparing using\n   * [the `Document.equals()` function.](./api.html#document_Document-equals)\n   *\n   * ####Examples:\n   *\n   *     doc.array.pull(ObjectId)\n   *     doc.array.pull({ _id: 'someId' })\n   *     doc.array.pull(36)\n   *     doc.array.pull('tag 1', 'tag 2')\n   *\n   * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n   *\n   * Or we may passing the _id directly and let mongoose take care of it.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull(4815162342); // works\n   *\n   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n   *\n   * @param {any} [args...]\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n   * @api public\n   * @method pull\n   * @receiver MongooseArray\n   */\n\n  pull: function() {\n    var values = [].map.call(arguments, this._cast, this),\n        cur = this._parent.get(this._path),\n        i = cur.length,\n        mem;\n\n    while (i--) {\n      mem = cur[i];\n      if (mem instanceof Document) {\n        var some = values.some(function(v) {\n          return mem.equals(v);\n        });\n        if (some) {\n          [].splice.call(cur, i, 1);\n        }\n      } else if (~cur.indexOf.call(values, mem)) {\n        [].splice.call(cur, i, 1);\n      }\n    }\n\n    if (values[0] instanceof EmbeddedDocument) {\n      this._registerAtomic('$pullDocs', values.map(function(v) {\n        return v._id || v;\n      }));\n    } else {\n      this._registerAtomic('$pullAll', values);\n    }\n\n    this._markModified();\n\n    // Might have modified child paths and then pulled, like\n    // `doc.children[1].name = 'test';` followed by\n    // `doc.children.remove(doc.children[0]);`. In this case we fall back\n    // to a `$set` on the whole array. See #3511\n    if (cleanModifiedSubpaths(this._parent, this._path) > 0) {\n      this._registerAtomic('$set', this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method splice\n   * @receiver MongooseArray\n   */\n\n  splice: function splice() {\n    var ret;\n    var vals;\n    var i;\n\n    _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));\n\n    if (arguments.length) {\n      vals = [];\n      for (i = 0; i < arguments.length; ++i) {\n        vals[i] = i < 2\n            ? arguments[i]\n            : this._cast(arguments[i], arguments[0] + (i - 2));\n      }\n      ret = [].splice.apply(this, vals);\n      this._registerAtomic('$set', this);\n      this._markModified();\n    }\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method unshift\n   * @receiver MongooseArray\n   */\n\n  unshift: function() {\n    _checkManualPopulation(this, arguments);\n\n    var values = [].map.call(arguments, this._cast, this);\n    values = this._schema.applySetters(values, this._parent);\n    [].unshift.apply(this, values);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return this.length;\n  },\n\n  /**\n   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method sort\n   * @receiver MongooseArray\n   */\n\n  sort: function() {\n    var ret = [].sort.apply(this, arguments);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Adds values to the array if not already present.\n   *\n   * ####Example:\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *     var added = doc.array.addToSet(4,5);\n   *     console.log(doc.array) // [2,3,4,5]\n   *     console.log(added)     // [5]\n   *\n   * @param {any} [args...]\n   * @return {Array} the values that were added\n   * @receiver MongooseArray\n   * @api public\n   * @method addToSet\n   */\n\n  addToSet: function addToSet() {\n    _checkManualPopulation(this, arguments);\n\n    var values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent);\n    var added = [];\n    var type = '';\n    if (values[0] instanceof EmbeddedDocument) {\n      type = 'doc';\n    } else if (values[0] instanceof Date) {\n      type = 'date';\n    }\n\n    values.forEach(function(v) {\n      var found;\n      switch (type) {\n        case 'doc':\n          found = this.some(function(doc) {\n            return doc.equals(v);\n          });\n          break;\n        case 'date':\n          var val = +v;\n          found = this.some(function(d) {\n            return +d === val;\n          });\n          break;\n        default:\n          found = ~this.indexOf(v);\n      }\n\n      if (!found) {\n        [].push.call(this, v);\n        this._registerAtomic('$addToSet', v);\n        this._markModified();\n        [].push.call(added, v);\n      }\n    }, this);\n\n    return added;\n  },\n\n  /**\n   * Sets the casted `val` at index `i` and marks the array modified.\n   *\n   * ####Example:\n   *\n   *     // given documents based on the following\n   *     var Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n   *\n   *     var doc = new Doc({ array: [2,3,4] })\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *\n   *     doc.array.set(1,\"5\");\n   *     console.log(doc.array); // [2,5,4] // properly cast to number\n   *     doc.save() // the change is saved\n   *\n   *     // VS not using array#set\n   *     doc.array[1] = \"5\";\n   *     console.log(doc.array); // [2,\"5\",4] // no casting\n   *     doc.save() // change is not saved\n   *\n   * @return {Array} this\n   * @api public\n   * @method set\n   * @receiver MongooseArray\n   */\n\n  set: function set(i, val) {\n    var value = this._cast(val, i);\n    this[i] = value;\n    this._markModified(i);\n    return this;\n  },\n\n  /**\n   * Returns a native js Array.\n   *\n   * @param {Object} options\n   * @return {Array}\n   * @api public\n   * @method toObject\n   * @receiver MongooseArray\n   */\n\n  toObject: function(options) {\n    if (options && options.depopulate) {\n      options._isNested = true;\n      return this.map(function(doc) {\n        return doc instanceof Document\n            ? doc.toObject(options)\n            : doc;\n      });\n    }\n\n    return this.slice();\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @api public\n   * @method inspect\n   * @receiver MongooseArray\n   */\n\n  inspect: function() {\n    return JSON.stringify(this);\n  },\n\n  /**\n   * Return the index of `obj` or `-1` if not found.\n   *\n   * @param {Object} obj the item to look for\n   * @return {Number}\n   * @api public\n   * @method indexOf\n   * @receiver MongooseArray\n   */\n\n  indexOf: function indexOf(obj) {\n    if (obj instanceof ObjectId) {\n      obj = obj.toString();\n    }\n    for (var i = 0, len = this.length; i < len; ++i) {\n      if (obj == this[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n};\n\n/**\n * Alias of [pull](#types_array_MongooseArray-pull)\n *\n * @see MongooseArray#pull #types_array_MongooseArray-pull\n * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n * @api public\n * @memberOf MongooseArray\n * @method remove\n */\n\nMongooseArray.mixin.remove = MongooseArray.mixin.pull;\n\n/*!\n * ignore\n */\n\nfunction _isAllSubdocs(docs, ref) {\n  if (!ref) {\n    return false;\n  }\n  for (var i = 0; i < docs.length; ++i) {\n    var arg = docs[i];\n    if (arg == null) {\n      return false;\n    }\n    var model = arg.constructor;\n    if (!(arg instanceof Document) ||\n      (model.modelName !== ref && model.baseModelName !== ref)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/*!\n * ignore\n */\n\nfunction _checkManualPopulation(arr, docs) {\n  var ref = arr._schema.caster.options && arr._schema.caster.options.ref;\n  if (arr.length === 0 &&\n      docs.length > 0) {\n    if (_isAllSubdocs(docs, ref)) {\n      arr._parent.populated(arr._path, [], { model: docs[0].constructor });\n    }\n  }\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseArray;\n"]},"metadata":{},"sourceType":"script"}