{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar EventEmitter = require('events').EventEmitter;\n\nfunction toArray(arr, start, end) {\n  return Array.prototype.slice.call(arr, start, end);\n}\n\nfunction strongUnshift(x, arrLike) {\n  var arr = toArray(arrLike);\n  arr.unshift(x);\n  return arr;\n}\n/**\n * MPromise constructor.\n *\n * _NOTE: The success and failure event names can be overridden by setting `Promise.SUCCESS` and `Promise.FAILURE` respectively._\n *\n * @param {Function} back a function that accepts `fn(err, ...){}` as signature\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `reject`: Emits when the promise is rejected (event name may be overridden)\n * @event `fulfill`: Emits when the promise is fulfilled (event name may be overridden)\n * @api public\n */\n\n\nfunction Promise(back) {\n  this.emitter = new EventEmitter();\n  this.emitted = {};\n  this.ended = false;\n\n  if ('function' == typeof back) {\n    this.ended = true;\n    this.onResolve(back);\n  }\n}\n/*\n * Module exports.\n */\n\n\nmodule.exports = Promise;\n/*!\n * event names\n */\n\nPromise.SUCCESS = 'fulfill';\nPromise.FAILURE = 'reject';\n/**\n * Adds `listener` to the `event`.\n *\n * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.\n *\n * @param {String} event\n * @param {Function} callback\n * @return {MPromise} this\n * @api private\n */\n\nPromise.prototype.on = function (event, callback) {\n  if (this.emitted[event]) callback.apply(undefined, this.emitted[event]);else this.emitter.on(event, callback);\n  return this;\n};\n/**\n * Keeps track of emitted events to run them on `on`.\n *\n * @api private\n */\n\n\nPromise.prototype.safeEmit = function (event) {\n  // ensures a promise can't be fulfill() or reject() more than once\n  if (event == Promise.SUCCESS || event == Promise.FAILURE) {\n    if (this.emitted[Promise.SUCCESS] || this.emitted[Promise.FAILURE]) {\n      return this;\n    }\n\n    this.emitted[event] = toArray(arguments, 1);\n  }\n\n  this.emitter.emit.apply(this.emitter, arguments);\n  return this;\n};\n/**\n * @api private\n */\n\n\nPromise.prototype.hasRejectListeners = function () {\n  return EventEmitter.listenerCount(this.emitter, Promise.FAILURE) > 0;\n};\n/**\n * Fulfills this promise with passed arguments.\n *\n * If this promise has already been fulfilled or rejected, no action is taken.\n *\n * @api public\n */\n\n\nPromise.prototype.fulfill = function () {\n  return this.safeEmit.apply(this, strongUnshift(Promise.SUCCESS, arguments));\n};\n/**\n * Rejects this promise with `reason`.\n *\n * If this promise has already been fulfilled or rejected, no action is taken.\n *\n * @api public\n * @param {Object|String} reason\n * @return {MPromise} this\n */\n\n\nPromise.prototype.reject = function (reason) {\n  if (this.ended && !this.hasRejectListeners()) throw reason;\n  return this.safeEmit(Promise.FAILURE, reason);\n};\n/**\n * Resolves this promise to a rejected state if `err` is passed or\n * fulfilled state if no `err` is passed.\n *\n * @param {Error} [err] error or null\n * @param {Object} [val] value to fulfill the promise with\n * @api public\n */\n\n\nPromise.prototype.resolve = function (err, val) {\n  if (err) return this.reject(err);\n  return this.fulfill(val);\n};\n/**\n * Adds a listener to the SUCCESS event.\n *\n * @return {MPromise} this\n * @api public\n */\n\n\nPromise.prototype.onFulfill = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  return this.on(Promise.SUCCESS, fn);\n};\n/**\n * Adds a listener to the FAILURE event.\n *\n * @return {MPromise} this\n * @api public\n */\n\n\nPromise.prototype.onReject = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  return this.on(Promise.FAILURE, fn);\n};\n/**\n * Adds a single function as a listener to both SUCCESS and FAILURE.\n *\n * It will be executed with traditional node.js argument position:\n * function (err, args...) {}\n *\n * Also marks the promise as `end`ed, since it's the common use-case, and yet has no\n * side effects unless `fn` is undefined or null.\n *\n * @param {Function} fn\n * @return {MPromise} this\n */\n\n\nPromise.prototype.onResolve = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  this.on(Promise.FAILURE, function (err) {\n    fn.call(this, err);\n  });\n  this.on(Promise.SUCCESS, function () {\n    fn.apply(this, strongUnshift(null, arguments));\n  });\n  return this;\n};\n/**\n * Creates a new promise and returns it. If `onFulfill` or\n * `onReject` are passed, they are added as SUCCESS/ERROR callbacks\n * to this promise after the next tick.\n *\n * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification. Read for more detail how to use this method.\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function (arg) {\n *       return arg + 1;\n *     }).then(function (arg) {\n *       throw new Error(arg + ' is an error!');\n *     }).then(null, function (err) {\n *       assert.ok(err instanceof Error);\n *       assert.equal('2 is an error', err.message);\n *     });\n *     p.complete(1);\n *\n * @see promises-A+ https://github.com/promises-aplus/promises-spec\n * @param {Function} onFulfill\n * @param {Function} [onReject]\n * @return {MPromise} newPromise\n */\n\n\nPromise.prototype.then = function (onFulfill, onReject) {\n  var newPromise = new Promise();\n\n  if ('function' == typeof onFulfill) {\n    this.onFulfill(handler(newPromise, onFulfill));\n  } else {\n    this.onFulfill(newPromise.fulfill.bind(newPromise));\n  }\n\n  if ('function' == typeof onReject) {\n    this.onReject(handler(newPromise, onReject));\n  } else {\n    this.onReject(newPromise.reject.bind(newPromise));\n  }\n\n  return newPromise;\n};\n\nfunction handler(promise, fn) {\n  function newTickHandler() {\n    var pDomain = promise.emitter.domain;\n    if (pDomain && pDomain !== process.domain) pDomain.enter();\n\n    try {\n      var x = fn.apply(undefined, boundHandler.args);\n    } catch (err) {\n      promise.reject(err);\n      return;\n    }\n\n    resolve(promise, x);\n  }\n\n  function boundHandler() {\n    boundHandler.args = arguments;\n    process.nextTick(newTickHandler);\n  }\n\n  return boundHandler;\n}\n\nfunction resolve(promise, x) {\n  function fulfillOnce() {\n    if (done++) return;\n    resolve.apply(undefined, strongUnshift(promise, arguments));\n  }\n\n  function rejectOnce(reason) {\n    if (done++) return;\n    promise.reject(reason);\n  }\n\n  if (promise === x) {\n    promise.reject(new TypeError(\"promise and x are the same\"));\n    return;\n  }\n\n  var rest = toArray(arguments, 1);\n  var type = typeof x;\n\n  if ('undefined' == type || null == x || !('object' == type || 'function' == type)) {\n    promise.fulfill.apply(promise, rest);\n    return;\n  }\n\n  try {\n    var theThen = x.then;\n  } catch (err) {\n    promise.reject(err);\n    return;\n  }\n\n  if ('function' != typeof theThen) {\n    promise.fulfill.apply(promise, rest);\n    return;\n  }\n\n  var done = 0;\n\n  try {\n    var ret = theThen.call(x, fulfillOnce, rejectOnce);\n    return ret;\n  } catch (err) {\n    if (done++) return;\n    promise.reject(err);\n  }\n}\n/**\n * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function(){ throw new Error('shucks') });\n *     setTimeout(function () {\n *       p.fulfill();\n *       // error was caught and swallowed by the promise returned from\n *       // p.then(). we either have to always register handlers on\n *       // the returned promises or we can do the following...\n *     }, 10);\n *\n *     // this time we use .end() which prevents catching thrown errors\n *     var p = new Promise;\n *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--\n *     setTimeout(function () {\n *       p.fulfill(); // throws \"shucks\"\n *     }, 10);\n *\n * @api public\n * @param {Function} [onReject]\n * @return {MPromise} this\n */\n\n\nPromise.prototype.end = Promise.prototype['catch'] = function (onReject) {\n  if (!onReject && !this.hasRejectListeners()) onReject = function idRejector(e) {\n    throw e;\n  };\n  this.onReject(onReject);\n  this.ended = true;\n  return this;\n};\n/**\n * A debug utility function that adds handlers to a promise that will log some output to the `console`\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function(){ throw new Error('shucks') });\n *     setTimeout(function () {\n *       p.fulfill();\n *       // error was caught and swallowed by the promise returned from\n *       // p.then(). we either have to always register handlers on\n *       // the returned promises or we can do the following...\n *     }, 10);\n *\n *     // this time we use .end() which prevents catching thrown errors\n *     var p = new Promise;\n *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--\n *     setTimeout(function () {\n *       p.fulfill(); // throws \"shucks\"\n *     }, 10);\n *\n * @api public\n * @param {MPromise} p\n * @param {String} name\n * @return {MPromise} this\n */\n\n\nPromise.trace = function (p, name) {\n  p.then(function () {\n    console.log(\"%s fulfill %j\", name, toArray(arguments));\n  }, function () {\n    console.log(\"%s reject %j\", name, toArray(arguments));\n  });\n};\n\nPromise.prototype.chain = function (p2) {\n  var p1 = this;\n  p1.onFulfill(p2.fulfill.bind(p2));\n  p1.onReject(p2.reject.bind(p2));\n  return p2;\n};\n\nPromise.prototype.all = function (promiseOfArr) {\n  var pRet = new Promise();\n  this.then(promiseOfArr).then(function (promiseArr) {\n    var count = 0;\n    var ret = [];\n    var errSentinel;\n    if (!promiseArr.length) pRet.resolve();\n    promiseArr.forEach(function (promise, index) {\n      if (errSentinel) return;\n      count++;\n      promise.then(function (val) {\n        if (errSentinel) return;\n        ret[index] = val;\n        --count;\n        if (count == 0) pRet.fulfill(ret);\n      }, function (err) {\n        if (errSentinel) return;\n        errSentinel = err;\n        pRet.reject(err);\n      });\n    });\n    return pRet;\n  }, pRet.reject.bind(pRet));\n  return pRet;\n};\n\nPromise.hook = function (arr) {\n  var p1 = new Promise();\n  var pFinal = new Promise();\n\n  var signalP = function () {\n    --count;\n    if (count == 0) pFinal.fulfill();\n    return pFinal;\n  };\n\n  var count = 1;\n  var ps = p1;\n  arr.forEach(function (hook) {\n    ps = ps.then(function () {\n      var p = new Promise();\n      count++;\n      hook(p.resolve.bind(p), signalP);\n      return p;\n    });\n  });\n  ps = ps.then(signalP);\n  p1.resolve();\n  return ps;\n};\n/* This is for the A+ tests, but it's very useful as well */\n\n\nPromise.fulfilled = function fulfilled() {\n  var p = new Promise();\n  p.fulfill.apply(p, arguments);\n  return p;\n};\n\nPromise.rejected = function rejected(reason) {\n  return new Promise().reject(reason);\n};\n\nPromise.deferred = function deferred() {\n  var p = new Promise();\n  return {\n    promise: p,\n    reject: p.reject.bind(p),\n    resolve: p.fulfill.bind(p),\n    callback: p.resolve.bind(p)\n  };\n};\n/* End A+ tests adapter bit */","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/mpromise/lib/promise.js"],"names":["util","require","EventEmitter","toArray","arr","start","end","Array","prototype","slice","call","strongUnshift","x","arrLike","unshift","Promise","back","emitter","emitted","ended","onResolve","module","exports","SUCCESS","FAILURE","on","event","callback","apply","undefined","safeEmit","arguments","emit","hasRejectListeners","listenerCount","fulfill","reject","reason","resolve","err","val","onFulfill","fn","TypeError","onReject","then","newPromise","handler","bind","promise","newTickHandler","pDomain","domain","process","enter","boundHandler","args","nextTick","fulfillOnce","done","rejectOnce","rest","type","theThen","ret","idRejector","e","trace","p","name","console","log","chain","p2","p1","all","promiseOfArr","pRet","promiseArr","count","errSentinel","length","forEach","index","hook","pFinal","signalP","ps","fulfilled","rejected","deferred"],"mappings":"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","sourcesContent":["'use strict';\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nfunction toArray(arr, start, end) {\n  return Array.prototype.slice.call(arr, start, end)\n}\nfunction strongUnshift(x, arrLike) {\n  var arr = toArray(arrLike);\n  arr.unshift(x);\n  return arr;\n}\n\n\n/**\n * MPromise constructor.\n *\n * _NOTE: The success and failure event names can be overridden by setting `Promise.SUCCESS` and `Promise.FAILURE` respectively._\n *\n * @param {Function} back a function that accepts `fn(err, ...){}` as signature\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `reject`: Emits when the promise is rejected (event name may be overridden)\n * @event `fulfill`: Emits when the promise is fulfilled (event name may be overridden)\n * @api public\n */\nfunction Promise(back) {\n  this.emitter = new EventEmitter();\n  this.emitted = {};\n  this.ended = false;\n  if ('function' == typeof back) {\n    this.ended = true;\n    this.onResolve(back);\n  }\n}\n\n\n/*\n * Module exports.\n */\nmodule.exports = Promise;\n\n\n/*!\n * event names\n */\nPromise.SUCCESS = 'fulfill';\nPromise.FAILURE = 'reject';\n\n\n/**\n * Adds `listener` to the `event`.\n *\n * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.\n *\n * @param {String} event\n * @param {Function} callback\n * @return {MPromise} this\n * @api private\n */\nPromise.prototype.on = function (event, callback) {\n  if (this.emitted[event])\n    callback.apply(undefined, this.emitted[event]);\n  else\n    this.emitter.on(event, callback);\n\n  return this;\n};\n\n\n/**\n * Keeps track of emitted events to run them on `on`.\n *\n * @api private\n */\nPromise.prototype.safeEmit = function (event) {\n  // ensures a promise can't be fulfill() or reject() more than once\n  if (event == Promise.SUCCESS || event == Promise.FAILURE) {\n    if (this.emitted[Promise.SUCCESS] || this.emitted[Promise.FAILURE]) {\n      return this;\n    }\n    this.emitted[event] = toArray(arguments, 1);\n  }\n\n  this.emitter.emit.apply(this.emitter, arguments);\n  return this;\n};\n\n\n/**\n * @api private\n */\nPromise.prototype.hasRejectListeners = function () {\n  return EventEmitter.listenerCount(this.emitter, Promise.FAILURE) > 0;\n};\n\n\n/**\n * Fulfills this promise with passed arguments.\n *\n * If this promise has already been fulfilled or rejected, no action is taken.\n *\n * @api public\n */\nPromise.prototype.fulfill = function () {\n  return this.safeEmit.apply(this, strongUnshift(Promise.SUCCESS, arguments));\n};\n\n\n/**\n * Rejects this promise with `reason`.\n *\n * If this promise has already been fulfilled or rejected, no action is taken.\n *\n * @api public\n * @param {Object|String} reason\n * @return {MPromise} this\n */\nPromise.prototype.reject = function (reason) {\n  if (this.ended && !this.hasRejectListeners())\n    throw reason;\n  return this.safeEmit(Promise.FAILURE, reason);\n};\n\n\n/**\n * Resolves this promise to a rejected state if `err` is passed or\n * fulfilled state if no `err` is passed.\n *\n * @param {Error} [err] error or null\n * @param {Object} [val] value to fulfill the promise with\n * @api public\n */\nPromise.prototype.resolve = function (err, val) {\n  if (err) return this.reject(err);\n  return this.fulfill(val);\n};\n\n\n/**\n * Adds a listener to the SUCCESS event.\n *\n * @return {MPromise} this\n * @api public\n */\nPromise.prototype.onFulfill = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  return this.on(Promise.SUCCESS, fn);\n};\n\n\n/**\n * Adds a listener to the FAILURE event.\n *\n * @return {MPromise} this\n * @api public\n */\nPromise.prototype.onReject = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  return this.on(Promise.FAILURE, fn);\n};\n\n\n/**\n * Adds a single function as a listener to both SUCCESS and FAILURE.\n *\n * It will be executed with traditional node.js argument position:\n * function (err, args...) {}\n *\n * Also marks the promise as `end`ed, since it's the common use-case, and yet has no\n * side effects unless `fn` is undefined or null.\n *\n * @param {Function} fn\n * @return {MPromise} this\n */\nPromise.prototype.onResolve = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  this.on(Promise.FAILURE, function (err) { fn.call(this, err); });\n  this.on(Promise.SUCCESS, function () { fn.apply(this, strongUnshift(null, arguments)); });\n  return this;\n};\n\n\n/**\n * Creates a new promise and returns it. If `onFulfill` or\n * `onReject` are passed, they are added as SUCCESS/ERROR callbacks\n * to this promise after the next tick.\n *\n * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification. Read for more detail how to use this method.\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function (arg) {\n *       return arg + 1;\n *     }).then(function (arg) {\n *       throw new Error(arg + ' is an error!');\n *     }).then(null, function (err) {\n *       assert.ok(err instanceof Error);\n *       assert.equal('2 is an error', err.message);\n *     });\n *     p.complete(1);\n *\n * @see promises-A+ https://github.com/promises-aplus/promises-spec\n * @param {Function} onFulfill\n * @param {Function} [onReject]\n * @return {MPromise} newPromise\n */\nPromise.prototype.then = function (onFulfill, onReject) {\n  var newPromise = new Promise;\n\n  if ('function' == typeof onFulfill) {\n    this.onFulfill(handler(newPromise, onFulfill));\n  } else {\n    this.onFulfill(newPromise.fulfill.bind(newPromise));\n  }\n\n  if ('function' == typeof onReject) {\n    this.onReject(handler(newPromise, onReject));\n  } else {\n    this.onReject(newPromise.reject.bind(newPromise));\n  }\n\n  return newPromise;\n};\n\n\nfunction handler(promise, fn) {\n  function newTickHandler() {\n    var pDomain = promise.emitter.domain;\n    if (pDomain && pDomain !== process.domain) pDomain.enter();\n    try {\n      var x = fn.apply(undefined, boundHandler.args);\n    } catch (err) {\n      promise.reject(err);\n      return;\n    }\n    resolve(promise, x);\n  }\n  function boundHandler() {\n    boundHandler.args = arguments;\n    process.nextTick(newTickHandler);\n  }\n  return boundHandler;\n}\n\n\nfunction resolve(promise, x) {\n  function fulfillOnce() {\n    if (done++) return;\n    resolve.apply(undefined, strongUnshift(promise, arguments));\n  }\n  function rejectOnce(reason) {\n    if (done++) return;\n    promise.reject(reason);\n  }\n\n  if (promise === x) {\n    promise.reject(new TypeError(\"promise and x are the same\"));\n    return;\n  }\n  var rest = toArray(arguments, 1);\n  var type = typeof x;\n  if ('undefined' == type || null == x || !('object' == type || 'function' == type)) {\n    promise.fulfill.apply(promise, rest);\n    return;\n  }\n\n  try {\n    var theThen = x.then;\n  } catch (err) {\n    promise.reject(err);\n    return;\n  }\n\n  if ('function' != typeof theThen) {\n    promise.fulfill.apply(promise, rest);\n    return;\n  }\n\n  var done = 0;\n  try {\n    var ret = theThen.call(x, fulfillOnce, rejectOnce);\n    return ret;\n  } catch (err) {\n    if (done++) return;\n    promise.reject(err);\n  }\n}\n\n\n/**\n * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function(){ throw new Error('shucks') });\n *     setTimeout(function () {\n *       p.fulfill();\n *       // error was caught and swallowed by the promise returned from\n *       // p.then(). we either have to always register handlers on\n *       // the returned promises or we can do the following...\n *     }, 10);\n *\n *     // this time we use .end() which prevents catching thrown errors\n *     var p = new Promise;\n *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--\n *     setTimeout(function () {\n *       p.fulfill(); // throws \"shucks\"\n *     }, 10);\n *\n * @api public\n * @param {Function} [onReject]\n * @return {MPromise} this\n */\nPromise.prototype.end = Promise.prototype['catch'] = function (onReject) {\n  if (!onReject && !this.hasRejectListeners())\n    onReject = function idRejector(e) { throw e; };\n  this.onReject(onReject);\n  this.ended = true;\n  return this;\n};\n\n\n/**\n * A debug utility function that adds handlers to a promise that will log some output to the `console`\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function(){ throw new Error('shucks') });\n *     setTimeout(function () {\n *       p.fulfill();\n *       // error was caught and swallowed by the promise returned from\n *       // p.then(). we either have to always register handlers on\n *       // the returned promises or we can do the following...\n *     }, 10);\n *\n *     // this time we use .end() which prevents catching thrown errors\n *     var p = new Promise;\n *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--\n *     setTimeout(function () {\n *       p.fulfill(); // throws \"shucks\"\n *     }, 10);\n *\n * @api public\n * @param {MPromise} p\n * @param {String} name\n * @return {MPromise} this\n */\nPromise.trace = function (p, name) {\n  p.then(\n    function () {\n      console.log(\"%s fulfill %j\", name, toArray(arguments));\n    },\n    function () {\n      console.log(\"%s reject %j\", name, toArray(arguments));\n    }\n  )\n};\n\n\nPromise.prototype.chain = function (p2) {\n  var p1 = this;\n  p1.onFulfill(p2.fulfill.bind(p2));\n  p1.onReject(p2.reject.bind(p2));\n  return p2;\n};\n\n\nPromise.prototype.all = function (promiseOfArr) {\n  var pRet = new Promise;\n  this.then(promiseOfArr).then(\n    function (promiseArr) {\n      var count = 0;\n      var ret = [];\n      var errSentinel;\n      if (!promiseArr.length) pRet.resolve();\n      promiseArr.forEach(function (promise, index) {\n        if (errSentinel) return;\n        count++;\n        promise.then(\n          function (val) {\n            if (errSentinel) return;\n            ret[index] = val;\n            --count;\n            if (count == 0) pRet.fulfill(ret);\n          },\n          function (err) {\n            if (errSentinel) return;\n            errSentinel = err;\n            pRet.reject(err);\n          }\n        );\n      });\n      return pRet;\n    }\n    , pRet.reject.bind(pRet)\n  );\n  return pRet;\n};\n\n\nPromise.hook = function (arr) {\n  var p1 = new Promise;\n  var pFinal = new Promise;\n  var signalP = function () {\n    --count;\n    if (count == 0)\n      pFinal.fulfill();\n    return pFinal;\n  };\n  var count = 1;\n  var ps = p1;\n  arr.forEach(function (hook) {\n    ps = ps.then(\n      function () {\n        var p = new Promise;\n        count++;\n        hook(p.resolve.bind(p), signalP);\n        return p;\n      }\n    )\n  });\n  ps = ps.then(signalP);\n  p1.resolve();\n  return ps;\n};\n\n\n/* This is for the A+ tests, but it's very useful as well */\nPromise.fulfilled = function fulfilled() { var p = new Promise; p.fulfill.apply(p, arguments); return p; };\nPromise.rejected = function rejected(reason) { return new Promise().reject(reason); };\nPromise.deferred = function deferred() {\n  var p = new Promise;\n  return {\n    promise: p,\n    reject: p.reject.bind(p),\n    resolve: p.fulfill.bind(p),\n    callback: p.resolve.bind(p)\n  }\n};\n/* End A+ tests adapter bit */\n"]},"metadata":{},"sourceType":"script"}