{"ast":null,"code":"'use strict';\n\nvar Document;\n\nvar utils = require('../../utils');\n/*!\n * exports\n */\n\n\nexports.compile = compile;\nexports.defineKey = defineKey;\n/*!\n * Compiles schemas.\n */\n\nfunction compile(tree, proto, prefix, options) {\n  Document = Document || require('../../document');\n  var keys = Object.keys(tree);\n  var i = keys.length;\n  var len = keys.length;\n  var limb;\n  var key;\n\n  if (options.retainKeyOrder) {\n    for (i = 0; i < len; ++i) {\n      key = keys[i];\n      limb = tree[key];\n      defineKey(key, utils.getFunctionName(limb.constructor) === 'Object' && Object.keys(limb).length && (!limb[options.typeKey] || options.typeKey === 'type' && limb.type.type) ? limb : null, proto, prefix, keys, options);\n    }\n  } else {\n    while (i--) {\n      key = keys[i];\n      limb = tree[key];\n      defineKey(key, utils.getFunctionName(limb.constructor) === 'Object' && Object.keys(limb).length && (!limb[options.typeKey] || options.typeKey === 'type' && limb.type.type) ? limb : null, proto, prefix, keys, options);\n    }\n  }\n}\n/*!\n * Defines the accessor named prop on the incoming prototype.\n */\n\n\nfunction defineKey(prop, subprops, prototype, prefix, keys, options) {\n  Document = Document || require('../../document');\n  var path = (prefix ? prefix + '.' : '') + prop;\n  prefix = prefix || '';\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n        var _this = this;\n\n        if (!this.$__.getters) {\n          this.$__.getters = {};\n        }\n\n        if (!this.$__.getters[path]) {\n          var nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this)); // save scope for nested getters/setters\n\n          if (!prefix) {\n            nested.$__.scope = this;\n          }\n\n          nested.$__.nestedPath = path;\n          Object.defineProperty(nested, 'schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n          Object.defineProperty(nested, 'toObject', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function () {\n              return utils.clone(_this.get(path), {\n                retainKeyOrder: true\n              });\n            }\n          });\n          Object.defineProperty(nested, 'toJSON', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function () {\n              return _this.get(path);\n            }\n          });\n          Object.defineProperty(nested, '$__isNested', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: true\n          });\n          compile(subprops, nested, path, options);\n          this.$__.getters[path] = nested;\n        }\n\n        return this.$__.getters[path];\n      },\n      set: function (v) {\n        if (v instanceof Document) {\n          v = v.toObject({\n            transform: false\n          });\n        }\n\n        var doc = this.$__.scope || this;\n        return doc.$set(path, v);\n      }\n    });\n  } else {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n        return this.get.call(this.$__.scope || this, path);\n      },\n      set: function (v) {\n        return this.$set.call(this.$__.scope || this, path, v);\n      }\n    });\n  }\n} // gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\n\n\nfunction getOwnPropertyDescriptors(object) {\n  var result = {};\n  Object.getOwnPropertyNames(object).forEach(function (key) {\n    result[key] = Object.getOwnPropertyDescriptor(object, key); // Assume these are schema paths, ignore them re: #5470\n\n    if (result[key].get) {\n      delete result[key];\n      return;\n    }\n\n    result[key].enumerable = ['isNew', '$__', 'errors', '_doc'].indexOf(key) === -1;\n  });\n  return result;\n}","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/mongoose/lib/services/document/compile.js"],"names":["Document","utils","require","exports","compile","defineKey","tree","proto","prefix","options","keys","Object","i","length","len","limb","key","retainKeyOrder","getFunctionName","constructor","typeKey","type","prop","subprops","prototype","path","defineProperty","enumerable","configurable","get","_this","$__","getters","nested","create","getOwnPropertyDescriptors","scope","nestedPath","writable","value","schema","clone","set","v","toObject","transform","doc","$set","call","object","result","getOwnPropertyNames","forEach","getOwnPropertyDescriptor","indexOf"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Document;\nvar utils = require('../../utils');\n\n/*!\n * exports\n */\n\nexports.compile = compile;\nexports.defineKey = defineKey;\n\n/*!\n * Compiles schemas.\n */\n\nfunction compile(tree, proto, prefix, options) {\n  Document = Document || require('../../document');\n  var keys = Object.keys(tree);\n  var i = keys.length;\n  var len = keys.length;\n  var limb;\n  var key;\n\n  if (options.retainKeyOrder) {\n    for (i = 0; i < len; ++i) {\n      key = keys[i];\n      limb = tree[key];\n\n      defineKey(key,\n          ((utils.getFunctionName(limb.constructor) === 'Object'\n          && Object.keys(limb).length)\n          && (!limb[options.typeKey] || (options.typeKey === 'type' && limb.type.type))\n              ? limb\n              : null)\n          , proto\n          , prefix\n          , keys\n          , options);\n    }\n  } else {\n    while (i--) {\n      key = keys[i];\n      limb = tree[key];\n\n      defineKey(key,\n          ((utils.getFunctionName(limb.constructor) === 'Object'\n          && Object.keys(limb).length)\n          && (!limb[options.typeKey] || (options.typeKey === 'type' && limb.type.type))\n              ? limb\n              : null)\n          , proto\n          , prefix\n          , keys\n          , options);\n    }\n  }\n}\n\n/*!\n * Defines the accessor named prop on the incoming prototype.\n */\n\nfunction defineKey(prop, subprops, prototype, prefix, keys, options) {\n  Document = Document || require('../../document');\n  var path = (prefix ? prefix + '.' : '') + prop;\n  prefix = prefix || '';\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        var _this = this;\n        if (!this.$__.getters) {\n          this.$__.getters = {};\n        }\n\n        if (!this.$__.getters[path]) {\n          var nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));\n\n          // save scope for nested getters/setters\n          if (!prefix) {\n            nested.$__.scope = this;\n          }\n          nested.$__.nestedPath = path;\n\n          Object.defineProperty(nested, 'schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, 'toObject', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return utils.clone(_this.get(path), { retainKeyOrder: true });\n            }\n          });\n\n          Object.defineProperty(nested, 'toJSON', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path);\n            }\n          });\n\n          Object.defineProperty(nested, '$__isNested', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: true\n          });\n\n          compile(subprops, nested, path, options);\n          this.$__.getters[path] = nested;\n        }\n\n        return this.$__.getters[path];\n      },\n      set: function(v) {\n        if (v instanceof Document) {\n          v = v.toObject({ transform: false });\n        }\n        var doc = this.$__.scope || this;\n        return doc.$set(path, v);\n      }\n    });\n  } else {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        return this.get.call(this.$__.scope || this, path);\n      },\n      set: function(v) {\n        return this.$set.call(this.$__.scope || this, path, v);\n      }\n    });\n  }\n}\n\n// gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\nfunction getOwnPropertyDescriptors(object) {\n  var result = {};\n\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    // Assume these are schema paths, ignore them re: #5470\n    if (result[key].get) {\n      delete result[key];\n      return;\n    }\n    result[key].enumerable = ['isNew', '$__', 'errors', '_doc'].indexOf(key) === -1;\n  });\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"script"}