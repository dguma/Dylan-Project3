{"ast":null,"code":"// Make sure Map exists for old Node.js versions\nvar Map = global.Map != null ? global.Map : function () {}; // These properties are special and can open client libraries to security\n// issues\n\nvar ignoreProperties = ['__proto__', 'constructor', 'prototype'];\n/**\n * Returns the value of object `o` at the given `path`.\n *\n * ####Example:\n *\n *     var obj = {\n *         comments: [\n *             { title: 'exciting!', _doc: { title: 'great!' }}\n *           , { title: 'number dos' }\n *         ]\n *     }\n *\n *     mpath.get('comments.0.title', o)         // 'exciting!'\n *     mpath.get('comments.0.title', o, '_doc') // 'great!'\n *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']\n *\n *     // summary\n *     mpath.get(path, o)\n *     mpath.get(path, o, special)\n *     mpath.get(path, o, map)\n *     mpath.get(path, o, special, map)\n *\n * @param {String} path\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which receives each individual found value. The value returned from `map` is used in the original values place.\n */\n\nexports.get = function (path, o, special, map) {\n  var lookup;\n\n  if ('function' == typeof special) {\n    if (special.length < 2) {\n      map = special;\n      special = undefined;\n    } else {\n      lookup = special;\n      special = undefined;\n    }\n  }\n\n  map || (map = K);\n  var parts = 'string' == typeof path ? path.split('.') : path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  var obj = o,\n      part;\n\n  for (var i = 0; i < parts.length; ++i) {\n    part = parts[i];\n\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n      // reading a property from the array items\n      var paths = parts.slice(i);\n      return obj.map(function (item) {\n        return item ? exports.get(paths, item, special || lookup, map) : map(undefined);\n      });\n    }\n\n    if (lookup) {\n      obj = lookup(obj, part);\n    } else {\n      var _from = special && obj[special] ? obj[special] : obj;\n\n      obj = _from instanceof Map ? _from.get(part) : _from[part];\n    }\n\n    if (!obj) return map(obj);\n  }\n\n  return map(obj);\n};\n/**\n * Returns true if `in` returns true for every piece of the path\n *\n * @param {String} path\n * @param {Object} o\n */\n\n\nexports.has = function (path, o) {\n  var parts = typeof path === 'string' ? path.split('.') : path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  var len = parts.length;\n  var cur = o;\n\n  for (var i = 0; i < len; ++i) {\n    if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\n      return false;\n    }\n\n    cur = cur[parts[i]];\n  }\n\n  return true;\n};\n/**\n * Deletes the last piece of `path`\n *\n * @param {String} path\n * @param {Object} o\n */\n\n\nexports.unset = function (path, o) {\n  var parts = typeof path === 'string' ? path.split('.') : path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  var len = parts.length;\n  var cur = o;\n\n  for (var i = 0; i < len; ++i) {\n    if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\n      return false;\n    } // Disallow any updates to __proto__ or special properties.\n\n\n    if (ignoreProperties.indexOf(parts[i]) !== -1) {\n      return false;\n    }\n\n    if (i === len - 1) {\n      delete cur[parts[i]];\n      return true;\n    }\n\n    cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];\n  }\n\n  return true;\n};\n/**\n * Sets the `val` at the given `path` of object `o`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which is passed each individual value before setting it. The value returned from `map` is used in the original values place.\n */\n\n\nexports.set = function (path, val, o, special, map, _copying) {\n  var lookup;\n\n  if ('function' == typeof special) {\n    if (special.length < 2) {\n      map = special;\n      special = undefined;\n    } else {\n      lookup = special;\n      special = undefined;\n    }\n  }\n\n  map || (map = K);\n  var parts = 'string' == typeof path ? path.split('.') : path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  if (null == o) return;\n\n  for (var i = 0; i < parts.length; ++i) {\n    // Silently ignore any updates to `__proto__`, these are potentially\n    // dangerous if using mpath with unsanitized data.\n    if (ignoreProperties.indexOf(parts[i]) !== -1) {\n      return;\n    }\n  } // the existance of $ in a path tells us if the user desires\n  // the copying of an array instead of setting each value of\n  // the array to the one by one to matching positions of the\n  // current array. Unless the user explicitly opted out by passing\n  // false, see Automattic/mongoose#6273\n\n\n  var copy = _copying || /\\$/.test(path) && _copying !== false,\n      obj = o,\n      part;\n\n  for (var i = 0, len = parts.length - 1; i < len; ++i) {\n    part = parts[i];\n\n    if ('$' == part) {\n      if (i == len - 1) {\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n      var paths = parts.slice(i);\n\n      if (!copy && Array.isArray(val)) {\n        for (var j = 0; j < obj.length && j < val.length; ++j) {\n          // assignment of single values of array\n          exports.set(paths, val[j], obj[j], special || lookup, map, copy);\n        }\n      } else {\n        for (var j = 0; j < obj.length; ++j) {\n          // assignment of entire value\n          exports.set(paths, val, obj[j], special || lookup, map, copy);\n        }\n      }\n\n      return;\n    }\n\n    if (lookup) {\n      obj = lookup(obj, part);\n    } else {\n      var _to = special && obj[special] ? obj[special] : obj;\n\n      obj = _to instanceof Map ? _to.get(part) : _to[part];\n    }\n\n    if (!obj) return;\n  } // process the last property of the path\n\n\n  part = parts[len]; // use the special property if exists\n\n  if (special && obj[special]) {\n    obj = obj[special];\n  } // set the value on the last branch\n\n\n  if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n    if (!copy && Array.isArray(val)) {\n      for (var item, j = 0; j < obj.length && j < val.length; ++j) {\n        item = obj[j];\n\n        if (item) {\n          if (lookup) {\n            lookup(item, part, map(val[j]));\n          } else {\n            if (item[special]) item = item[special];\n            item[part] = map(val[j]);\n          }\n        }\n      }\n    } else {\n      for (var j = 0; j < obj.length; ++j) {\n        item = obj[j];\n\n        if (item) {\n          if (lookup) {\n            lookup(item, part, map(val));\n          } else {\n            if (item[special]) item = item[special];\n            item[part] = map(val);\n          }\n        }\n      }\n    }\n  } else {\n    if (lookup) {\n      lookup(obj, part, map(val));\n    } else if (obj instanceof Map) {\n      obj.set(part, map(val));\n    } else {\n      obj[part] = map(val);\n    }\n  }\n};\n/*!\n * Returns the value passed to it.\n */\n\n\nfunction K(v) {\n  return v;\n}","map":{"version":3,"sources":["/home/pumaguma/Desktop/project-draft/front/node_modules/mpath/lib/index.js"],"names":["Map","global","ignoreProperties","exports","get","path","o","special","map","lookup","length","undefined","K","parts","split","Array","isArray","TypeError","obj","part","i","test","paths","slice","item","_from","has","len","cur","unset","indexOf","set","val","_copying","copy","j","_to","v"],"mappings":"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","sourcesContent":["// Make sure Map exists for old Node.js versions\nvar Map = global.Map != null ? global.Map : function() {};\n\n// These properties are special and can open client libraries to security\n// issues\nvar ignoreProperties = ['__proto__', 'constructor', 'prototype'];\n\n/**\n * Returns the value of object `o` at the given `path`.\n *\n * ####Example:\n *\n *     var obj = {\n *         comments: [\n *             { title: 'exciting!', _doc: { title: 'great!' }}\n *           , { title: 'number dos' }\n *         ]\n *     }\n *\n *     mpath.get('comments.0.title', o)         // 'exciting!'\n *     mpath.get('comments.0.title', o, '_doc') // 'great!'\n *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']\n *\n *     // summary\n *     mpath.get(path, o)\n *     mpath.get(path, o, special)\n *     mpath.get(path, o, map)\n *     mpath.get(path, o, special, map)\n *\n * @param {String} path\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which receives each individual found value. The value returned from `map` is used in the original values place.\n */\n\nexports.get = function (path, o, special, map) {\n  var lookup;\n\n  if ('function' == typeof special) {\n    if (special.length < 2) {\n      map = special;\n      special = undefined;\n    } else {\n      lookup = special;\n      special = undefined;\n    }\n  }\n\n  map || (map = K);\n\n  var parts = 'string' == typeof path\n    ? path.split('.')\n    : path\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  var obj = o\n    , part;\n\n  for (var i = 0; i < parts.length; ++i) {\n    part = parts[i];\n\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n      // reading a property from the array items\n      var paths = parts.slice(i);\n\n      return obj.map(function (item) {\n        return item\n          ? exports.get(paths, item, special || lookup, map)\n          : map(undefined);\n      });\n    }\n\n    if (lookup) {\n      obj = lookup(obj, part);\n    } else {\n      var _from = special && obj[special] ? obj[special] : obj;\n      obj = _from instanceof Map ?\n        _from.get(part) :\n        _from[part];\n    }\n\n    if (!obj) return map(obj);\n  }\n\n  return map(obj);\n};\n\n/**\n * Returns true if `in` returns true for every piece of the path\n *\n * @param {String} path\n * @param {Object} o\n */\n\nexports.has = function (path, o) {\n  var parts = typeof path === 'string' ?\n    path.split('.') :\n    path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  var len = parts.length;\n  var cur = o;\n  for (var i = 0; i < len; ++i) {\n    if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\n      return false;\n    }\n    cur = cur[parts[i]];\n  }\n\n  return true;\n};\n\n/**\n * Deletes the last piece of `path`\n *\n * @param {String} path\n * @param {Object} o\n */\n\nexports.unset = function (path, o) {\n  var parts = typeof path === 'string' ?\n    path.split('.') :\n    path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  var len = parts.length;\n  var cur = o;\n  for (var i = 0; i < len; ++i) {\n    if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\n      return false;\n    }\n    // Disallow any updates to __proto__ or special properties.\n    if (ignoreProperties.indexOf(parts[i]) !== -1) {\n      return false;\n    }\n    if (i === len - 1) {\n      delete cur[parts[i]];\n      return true;\n    }\n    cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];\n  }\n\n  return true;\n};\n\n/**\n * Sets the `val` at the given `path` of object `o`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which is passed each individual value before setting it. The value returned from `map` is used in the original values place.\n */\n\nexports.set = function (path, val, o, special, map, _copying) {\n  var lookup;\n\n  if ('function' == typeof special) {\n    if (special.length < 2) {\n      map = special;\n      special = undefined;\n    } else {\n      lookup = special;\n      special = undefined;\n    }\n  }\n\n  map || (map = K);\n\n  var parts = 'string' == typeof path\n    ? path.split('.')\n    : path\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  if (null == o) return;\n\n  for (var i = 0; i < parts.length; ++i) {\n    // Silently ignore any updates to `__proto__`, these are potentially\n    // dangerous if using mpath with unsanitized data.\n    if (ignoreProperties.indexOf(parts[i]) !== -1) {\n      return;\n    }\n  }\n\n  // the existance of $ in a path tells us if the user desires\n  // the copying of an array instead of setting each value of\n  // the array to the one by one to matching positions of the\n  // current array. Unless the user explicitly opted out by passing\n  // false, see Automattic/mongoose#6273\n  var copy = _copying || (/\\$/.test(path) && _copying !== false)\n    , obj = o\n    , part\n\n  for (var i = 0, len = parts.length - 1; i < len; ++i) {\n    part = parts[i];\n\n    if ('$' == part) {\n      if (i == len - 1) {\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n      var paths = parts.slice(i);\n      if (!copy && Array.isArray(val)) {\n        for (var j = 0; j < obj.length && j < val.length; ++j) {\n          // assignment of single values of array\n          exports.set(paths, val[j], obj[j], special || lookup, map, copy);\n        }\n      } else {\n        for (var j = 0; j < obj.length; ++j) {\n          // assignment of entire value\n          exports.set(paths, val, obj[j], special || lookup, map, copy);\n        }\n      }\n      return;\n    }\n\n    if (lookup) {\n      obj = lookup(obj, part);\n    } else {\n      var _to = special && obj[special] ? obj[special] : obj;\n      obj = _to instanceof Map ?\n        _to.get(part) :\n        _to[part];\n    }\n\n    if (!obj) return;\n  }\n\n  // process the last property of the path\n\n  part = parts[len];\n\n  // use the special property if exists\n  if (special && obj[special]) {\n    obj = obj[special];\n  }\n\n  // set the value on the last branch\n  if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n    if (!copy && Array.isArray(val)) {\n      for (var item, j = 0; j < obj.length && j < val.length; ++j) {\n        item = obj[j];\n        if (item) {\n          if (lookup) {\n            lookup(item, part, map(val[j]));\n          } else {\n            if (item[special]) item = item[special];\n            item[part] = map(val[j]);\n          }\n        }\n      }\n    } else {\n      for (var j = 0; j < obj.length; ++j) {\n        item = obj[j];\n        if (item) {\n          if (lookup) {\n            lookup(item, part, map(val));\n          } else {\n            if (item[special]) item = item[special];\n            item[part] = map(val);\n          }\n        }\n      }\n    }\n  } else {\n    if (lookup) {\n      lookup(obj, part, map(val));\n    } else if (obj instanceof Map) {\n      obj.set(part, map(val));\n    } else {\n      obj[part] = map(val);\n    }\n  }\n}\n\n/*!\n * Returns the value passed to it.\n */\n\nfunction K (v) {\n  return v;\n}\n"]},"metadata":{},"sourceType":"script"}